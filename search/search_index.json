{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Latest Release: v0.6.5 (November 24, 2024) Download Changelog Documentation Getting Started See the changelog for the latest release notes and known issues. PySceneDetect is a tool for detecting shot changes in videos ( example ), and can automatically split the video into separate clips . PySceneDetect is free and open-source software, and has several detection methods to find fast-cuts and threshold-based fades. Quickstart Split video on each fast cut using command line (more examples) : scenedetect -i video.mp4 split-video Split video on each fast cut using Python API (docs) : from scenedetect import detect, AdaptiveDetector, split_video_ffmpeg scene_list = detect('my_video.mp4', AdaptiveDetector()) split_video_ffmpeg('my_video.mp4', scene_list) Examples and Use Cases Here are some of the things people are using PySceneDetect for: splitting home videos or other source footage into individual scenes automated detection and removal of commercials from PVR-saved video sources processing and splitting surveillance camera footage statistical analysis of videos to find suitable \"loops\" for looping GIFs/cinemagraphs academic analysis of film and video (e.g. finding mean shot length) Of course, this is just a small slice of what you can do with PySceneDetect, so why not try it out for yourself ! The timecode format used by default ( HH:MM:SS.nnnn ) is compatible with most popular video tools, so in most cases the output scene list from PySceneDetect can be directly copied and pasted into another tool of your choice (e.g. ffmpeg , avconv or the mkvtoolnix suite).","title":"Home"},{"location":"api/","text":"API Reference The Python API is documented using Sphinx and can be found here . Scene Detection Algorithms This page discusses the scene detection methods/algorithms available for use in PySceneDetect, including details describing the operation of the detection method, as well as relevant command-line arguments and recommended values. Content-Aware Detector The content-aware scene detector ( detect-content ) detects jump cuts in the input video. This is typically what people think of as \"cuts\" between scenes in a movie - given two adjacent frames, do they belong to the same scene? The content-aware scene detector finds areas where the difference between two subsequent frames exceeds the threshold value that is set (a good value to start with is --threshold 27 ). Internally, this detector functions by converting the colorspace of each decoded frame from RGB into HSV . It then takes the average difference across all channels (or optionally just the value channel) from frame to frame. When this exceeds a set threshold, a scene change is triggered. detect-content also has edge detection, which can be enabled by providing a set of 4 numbers in the form ( delta_hue , delta_sat , delta_lum , delta_edges ). Changes in edges are typically larger than the other components, so threshold may need to be increased accordingly. For example, -w 1.0 0.5 1.0 0.2 -t 32 is a good starting point to use with edge detection. The default weights are --weights 1.0 1.0 1.0 0.0 which does not include edges, but this may change in the future. See the documentation for detect-content for details. Adaptive Content Detector The adaptive content detector ( detect-adaptive ) compares the difference in content between adjacent frames similar to detect-content but instead using a rolling average of adjacent frame changes. This helps mitigate false detections where there is fast camera motion. Threshold Detector The threshold-based scene detector ( detect-threshold ) is how most traditional scene detection methods work (e.g. the ffmpeg blackframe filter), by comparing the intensity/brightness of the current frame with a set threshold, and triggering a scene cut/break when this value crosses the threshold. In PySceneDetect, this value is computed by averaging the R, G, and B values for every pixel in the frame, yielding a single floating point number representing the average pixel value (from 0.0 to 255.0). Histogram Detector The scene change detection algorithm uses histograms of the Y channel in the YCbCr color space to detect scene changes, which helps mitigate issues caused by lighting variations. Each frame of the video is converted from its original color space to the YCbCr color space.The Y channel, which represents luminance, is extracted from the YCbCr color space. This helps in focusing on intensity variations rather than color variations. A histogram of the Y channel is computed using the specified number of bins (--bins/-b). The histogram is normalized to ensure that it can be consistently compared with histograms from other frames. The normalized histogram of the current frame is compared with the normalized histogram of the previous frame using the correlation method (cv2.HISTCMP_CORREL). A scene change is detected if the correlation between the histograms of consecutive frames is below the specified threshold (--threshold/-t). This indicates a significant change in luminance, suggesting a scene change. Perceptual Hash Detector The perceptual hash detector ( detect-hash ) calculates a hash for a frame and compares that hash to the previous frame's hash. If the hashes differ by more than the defined threshold, then a scene change is recorded. The hashing algorithm used for this detector is an implementation of phash from the imagehash library. In practice, this detector works similarly to detect-content in that it picks up large differences between adjacent frames. One important note is that the hashing algorithm converts the frames to grayscale, so this detector is insensitive to changes in colors if the brightness remains constant. In general, this algorithm is very computationally efficient compared to detect-content or detect-adaptive , especially if downscaling is not used. See here for an overview of how a perceptual hashing algorithm can be used for detecting similarity (or otherwise) of images and a visual depiction of the algorithm. Creating New Detection Algorithms All scene detection algorithms must inherit from the base SceneDetector class . Note that the current SceneDetector API is under development and expected to change somewhat before v1.0 is released, so make sure to pin your scenedetect dependency to the correct API version (e.g. scenedetect < 0.6 , scenedetect < 0.7 , etc...). Creating a new scene detection method can be as simple as implementing the process_frame function, and optionally post_process : from scenedetect.scene_detector import SceneDetector class CustomDetector(SceneDetector): \"\"\"CustomDetector class to implement a scene detection algorithm.\"\"\" def __init__(self): pass def process_frame(self, frame_num, frame_img, frame_metrics, scene_list): \"\"\"Computes/stores metrics and detects any scene changes. Returns: A list containing 1 or more the frame numbers of any detected scenes. \"\"\" return [] def post_process(self, scene_list): pass process_frame is called on every frame in the input video, which will be called after the final frame of the video is passed to process_frame . This may be useful for multi-pass algorithms, or detectors which are waiting on some condition but still wish to output an event on the final frame. For example, a detector may output at most 1 cuts for every call to process_frame , it may output the entire scene list in post_process , or a combination of both. Note that the latter will not work in cases where a live video stream or camera input device is being used. See the API documentation for the SceneDetector class for details. Alternatively, you can call help(SceneDetector) from a Python REPL. For examples of actual detection algorithm implementations, see the source files in the scenedetect/detectors/ directory (e.g. threshold_detector.py , content_detector.py ). Processing is done by calling the process_frame(...) function for all frames in the video, followed by post_process(...) (optional) after the final frame. Scene cuts are detected and added to the passed list object in both cases. process_frame(...) is called for each frame in sequence, passing the following arguments: frame_num : the number of the current frame being processed frame_img : frame returned video file or stream (accessible as NumPy array) frame_metrics : dictionary for memoizing results of detection algorithm calculations for quicker subsequent analyses (if possible) scene_list : List containing the frame numbers where all scene cuts/breaks occur in the video. post_process(...) is called after the final frame has been processed, to allow for any stored scene cuts to be written if required (e.g. in the case of the ThresholdDetector ). You may also want to look into the implementation of current detectors to understand how frame metrics are saved/loaded to/from a StatsManager for caching and allowing values to be written to a stats file for users to graph and find trends in to tweak detector options. Also see the documentation for the SceneManager for details.","title":"Python API"},{"location":"api/#api-reference","text":"The Python API is documented using Sphinx and can be found here .","title":"API Reference"},{"location":"api/#scene-detection-algorithms","text":"This page discusses the scene detection methods/algorithms available for use in PySceneDetect, including details describing the operation of the detection method, as well as relevant command-line arguments and recommended values.","title":"Scene Detection Algorithms"},{"location":"api/#content-aware-detector","text":"The content-aware scene detector ( detect-content ) detects jump cuts in the input video. This is typically what people think of as \"cuts\" between scenes in a movie - given two adjacent frames, do they belong to the same scene? The content-aware scene detector finds areas where the difference between two subsequent frames exceeds the threshold value that is set (a good value to start with is --threshold 27 ). Internally, this detector functions by converting the colorspace of each decoded frame from RGB into HSV . It then takes the average difference across all channels (or optionally just the value channel) from frame to frame. When this exceeds a set threshold, a scene change is triggered. detect-content also has edge detection, which can be enabled by providing a set of 4 numbers in the form ( delta_hue , delta_sat , delta_lum , delta_edges ). Changes in edges are typically larger than the other components, so threshold may need to be increased accordingly. For example, -w 1.0 0.5 1.0 0.2 -t 32 is a good starting point to use with edge detection. The default weights are --weights 1.0 1.0 1.0 0.0 which does not include edges, but this may change in the future. See the documentation for detect-content for details.","title":"Content-Aware Detector"},{"location":"api/#adaptive-content-detector","text":"The adaptive content detector ( detect-adaptive ) compares the difference in content between adjacent frames similar to detect-content but instead using a rolling average of adjacent frame changes. This helps mitigate false detections where there is fast camera motion.","title":"Adaptive Content Detector"},{"location":"api/#threshold-detector","text":"The threshold-based scene detector ( detect-threshold ) is how most traditional scene detection methods work (e.g. the ffmpeg blackframe filter), by comparing the intensity/brightness of the current frame with a set threshold, and triggering a scene cut/break when this value crosses the threshold. In PySceneDetect, this value is computed by averaging the R, G, and B values for every pixel in the frame, yielding a single floating point number representing the average pixel value (from 0.0 to 255.0).","title":"Threshold Detector"},{"location":"api/#histogram-detector","text":"The scene change detection algorithm uses histograms of the Y channel in the YCbCr color space to detect scene changes, which helps mitigate issues caused by lighting variations. Each frame of the video is converted from its original color space to the YCbCr color space.The Y channel, which represents luminance, is extracted from the YCbCr color space. This helps in focusing on intensity variations rather than color variations. A histogram of the Y channel is computed using the specified number of bins (--bins/-b). The histogram is normalized to ensure that it can be consistently compared with histograms from other frames. The normalized histogram of the current frame is compared with the normalized histogram of the previous frame using the correlation method (cv2.HISTCMP_CORREL). A scene change is detected if the correlation between the histograms of consecutive frames is below the specified threshold (--threshold/-t). This indicates a significant change in luminance, suggesting a scene change.","title":"Histogram Detector"},{"location":"api/#perceptual-hash-detector","text":"The perceptual hash detector ( detect-hash ) calculates a hash for a frame and compares that hash to the previous frame's hash. If the hashes differ by more than the defined threshold, then a scene change is recorded. The hashing algorithm used for this detector is an implementation of phash from the imagehash library. In practice, this detector works similarly to detect-content in that it picks up large differences between adjacent frames. One important note is that the hashing algorithm converts the frames to grayscale, so this detector is insensitive to changes in colors if the brightness remains constant. In general, this algorithm is very computationally efficient compared to detect-content or detect-adaptive , especially if downscaling is not used. See here for an overview of how a perceptual hashing algorithm can be used for detecting similarity (or otherwise) of images and a visual depiction of the algorithm.","title":"Perceptual Hash Detector"},{"location":"api/#creating-new-detection-algorithms","text":"All scene detection algorithms must inherit from the base SceneDetector class . Note that the current SceneDetector API is under development and expected to change somewhat before v1.0 is released, so make sure to pin your scenedetect dependency to the correct API version (e.g. scenedetect < 0.6 , scenedetect < 0.7 , etc...). Creating a new scene detection method can be as simple as implementing the process_frame function, and optionally post_process : from scenedetect.scene_detector import SceneDetector class CustomDetector(SceneDetector): \"\"\"CustomDetector class to implement a scene detection algorithm.\"\"\" def __init__(self): pass def process_frame(self, frame_num, frame_img, frame_metrics, scene_list): \"\"\"Computes/stores metrics and detects any scene changes. Returns: A list containing 1 or more the frame numbers of any detected scenes. \"\"\" return [] def post_process(self, scene_list): pass process_frame is called on every frame in the input video, which will be called after the final frame of the video is passed to process_frame . This may be useful for multi-pass algorithms, or detectors which are waiting on some condition but still wish to output an event on the final frame. For example, a detector may output at most 1 cuts for every call to process_frame , it may output the entire scene list in post_process , or a combination of both. Note that the latter will not work in cases where a live video stream or camera input device is being used. See the API documentation for the SceneDetector class for details. Alternatively, you can call help(SceneDetector) from a Python REPL. For examples of actual detection algorithm implementations, see the source files in the scenedetect/detectors/ directory (e.g. threshold_detector.py , content_detector.py ). Processing is done by calling the process_frame(...) function for all frames in the video, followed by post_process(...) (optional) after the final frame. Scene cuts are detected and added to the passed list object in both cases. process_frame(...) is called for each frame in sequence, passing the following arguments: frame_num : the number of the current frame being processed frame_img : frame returned video file or stream (accessible as NumPy array) frame_metrics : dictionary for memoizing results of detection algorithm calculations for quicker subsequent analyses (if possible) scene_list : List containing the frame numbers where all scene cuts/breaks occur in the video. post_process(...) is called after the final frame has been processed, to allow for any stored scene cuts to be written if required (e.g. in the case of the ThresholdDetector ). You may also want to look into the implementation of current detectors to understand how frame metrics are saved/loaded to/from a StatsManager for caching and allowing values to be written to a stats file for users to graph and find trends in to tweak detector options. Also see the documentation for the SceneManager for details.","title":"Creating New Detection Algorithms"},{"location":"changelog/","text":"Releases PySceneDetect 0.6 PySceneDetect 0.6.5 (November 24, 2024) Release Notes This release brings crop support, performance improvements to save-images, lots of bugfixes, and improved compatibility with MoviePy 2.0+. Changelog [feature] Add ability to crop input video before processing #302 #449 [cli] Add --crop option to scenedetect command and config file to crop video frames before scene detection [api] Add crop property to SceneManager to crop video frames before scene detection [feature] Add ability to configure CSV separators for rows/columns in config file #423 [feature] Add new --show flag to export-html command to launch browser after processing #442 [improvement] Add new threading option to save-images / save_images() #456 Enabled by default, offloads image encoding and disk IO to separate threads Improves performance by up to 50% in some cases [improvement] The export-html command now implicitly invokes save-images with default parameters The output of the export-html command will always use the result of the save-images command that precedes it [improvement] save_to_csv now works with paths from pathlib [api] The save_to_csv function now works correctly with paths from the pathlib module [api] Add col_separator and row_separator args to write_scene_list function in scenedetect.scene_manager [api] The MoviePy backend now works with MoviePy 2.0+ [bugfix] Fix SyntaxWarning due to incorrect escaping #400 [bugfix] Fix ContentDetector crash when using callbacks #416 #420 [bugfix] Fix save-images / save_images() not working correctly with UTF-8 paths #450 [bugfix] Fix crash when using save-images / save_images() with OpenCV backend #455 [bugfix] Fix new detectors not working with default-detector config option [general] Timecodes of the form MM:SS[.nnn] are now processed correctly #443 [general] Updates to Windows distributions: The MoviePy backend is now included with Windows distributions Python 3.9 -> Python 3.13 PyAV 10 -> 13.1.0 OpenCV 4.10.0.82 -> 4.10.0.84 Ffmpeg 6.0 -> 7.1 Python Distribution Changes v0.6.5.1 - Fix compatibility issues with PyAV 14+ #466 v0.6.5.2 - Fix for AttributeError: module 'cv2' has no attribute 'Mat' #468 0.6.4 (June 10, 2024) Release Notes Includes new histogram and perceptual hash based detectors (thanks @wjs018 and @ash2703), adds flash filter to content detector, and includes various bugfixes. Below shows the scores of the new detectors normalized against detect-content for comparison on a difficult segment with 3 cuts: Feedback on the new detection methods and their default values is most welcome. Thanks to everyone who contributed for their help and support! Changelog [feature] New detectors: detect-hist / HistogramDetector #295 #53 detect-hash / HashDetector #290 [feature] Add flash suppression filter for detect-content / ContentDetector (enabled by default) #35 #53 Reduces number of cuts generated during strobing or flashing effects Can be configured using --filter-mode option --filter-mode = merge (new default) merges consecutive scenes shorter than min-scene-len --filter-mode = suppress (previous default) disables generating new scenes until min-scene-len has passed [feature] Add more templates for save-images filename customization: $TIMECODE , $FRAME_NUMBER , $TIMESTAMP_MS (thanks @Veldhoen0) #395 [bugfix] Remove extraneous console output when using --drop-short-scenes [bugfix] Fix scene lengths being smaller than min-scene-len when using detect-adaptive / AdaptiveDetector with large values of --frame-window [bugfix] Fix crash when decoded frames have incorrect resolution and log error instead #319 [bugfix] Update default ffmpeg stream mapping from -map 0 to -map 0:v:0 -map 0:a? -map 0:s? #392 0.6.3 (March 9, 2024) Release Notes In addition to some perfromance improvements with the load-scenes command, this release of PySceneDetect includes a significant amount of bugfixes. Thanks to everyone who contributed to the release, including those who filed bug reports and helped with debugging! Program Changes: [bugfix] Fix crash for some WebM videos when using save-images with --backend pyav #355 [bugfix] Correct --duration and --end for presentation time when specified as frame numbers #341 [bugfix] Progress bar now has correct frame accounting when --duration or --end are set #341 [bugfix] Only allow load-scenes to be specified once, and disallow with other detect-* commands #347 [bugfix] Disallow -s / --start being larger than -e / --end for the time command [bugfix] Fix detect-adaptive not respecting --min-scene-len for the first scene [general] Comma-separated timecode list is now only printed when the list-scenes command is specified #356 [general] Several changes to [list-scenes] config file options: Add display-scenes and display-cuts options to control output Add cut-format to control formatting of cut points #349 Valid values: frames , timecode , seconds [general] Increase progress bar indent to improve visibility and visual alignment [improvement] The s suffix for setting timecode values in seconds is no longer required (values without decimal places are still interpreted as frame numbers) [improvement] load-scenes now skips detection, generating output much faster #347 (thanks @wjs018 for the initial implementation) API Changes: [bugfix] Fix AttributeError thrown when accessing aspect_ratio on certain videos using VideoStreamAv #355 [bugfix] Fix circular imports due to partially initialized module for some development environments #350 [bugfix] Fix SceneManager.detect_scenes warning when duration or end_time are specified as timecode strings #346 [bugfix] Ensure correct string conversion behavior for FrameTimecode when rounding is enabled #354 [bugfix] Fix AdaptiveDetector not respecting min_scene_len for the first scene [feature] Add output_dir argument to split_video_ffmpeg and split_video_mkvmerge functions to set output directory #298 [feature] Add formatter argument to split_video_ffmpeg to allow formatting filenames via callback #359 [general] The frame_img argument to SceneDetector.process_frame() is now required [general] Remove TimecodeValue from scenedetect.frame_timecode (use typing.Union[int, float, str] ) [general] Remove MotionDetector and scenedetect.detectors.motion_detector module (will be reintroduced after SceneDetector interface is stable) [improvement] scenedetect.stats_manager module improvements: The StatsManager.register_metrics() method no longer throws any exceptions Add StatsManager.metric_keys property to query registered metric keys Deprecate FrameMetricRegistered and FrameMetricNotRegistered exceptions (no longer used) [improvement] When converting strings representing seconds to FrameTimecode , the s suffix is now optional, and whitespace is ignored (note that values without decimal places are still interpreted as frame numbers) [improvement] The VideoCaptureAdapter in scenedetect.backends.opencv now attempts to report duration if known 0.6.2 (July 23, 2023) Release Notes Includes new load-scenes command , ability to specify a default detector, PyAV 10 support, and several bugfixes. Minimum supported Python version is now Python 3.7 . Command-Line Changes: [feature] Add load-scenes command to load cuts from list-scenes CSV output #235 [feature] Use detect-adaptive by default if a detector is not specified #329 Default detector can be set by config file with the default-detector option under [global] [bugfix] Fix -d / --duration and -e / --end options of time command consuming one extra frame #307 [bugfix] Fix incorrect end timecode for final scene when last frame of video is a new scene #307 [bugfix] Expand $VIDEO_NAME before creating output directory for -f / --filename option of split-video , now allows absolute paths [general] Rename ThresholdDetector ( detect-threshold ) metric delta_rgb metric to average_rgb [general] -l / --logfile always produces debug logs now [general] Remove -a / --all flag from scenedetect version command, now prints all information by default (can still call scenedetect for version number alone) [general] Add -h / --help options globally and for each command [general] Remove all option from scenedetect help command (can now call scenedetect help for full reference) General: [feature] Add ability to specify method (floor/ceiling) when creating ThresholdDetector , allows fade to white detection #143 [general] Minimum supported Python version is now Python 3.7 [general] Add support for PyAV 10.0 #292 [general] Use platformdirs package instead of appdirs #309 [bugfix] Fix end_time always consuming one extra frame #307 [bugfix] Fix incorrect end timecode for last scene when start_in_scene is True or the final scene contains a single frame #307 [bugfix] Fix MoviePy read next frame #320 [bugfix] Template replacement when generating output now allows lower-case letters to be used as separators in addition to other characters [api] Make some public functions/methods private (prefixed with _ ): get_aspect_ratio function in scenedetect.backends.opencv mean_pixel_distance and estimated_kernel_size functions in scenedetect.detectors.content_detector compute_frame_average function in scenedetect.detectors.threshold_detector scenedetect.cli and scenedetect.thirdparty modules [api] Remove compute_downscale_factor in scenedetect.video_stream (use scenedetect.scene_manager.compute_downscale_factor instead) [dist] Updated dependencies in Windows distributions: ffmpeg 6.0, PyAV 10, OpenCV 4.8, removed mkvmerge Project Updates Website and documentation is now hosted on Github Pages, documentation can be found at scenedetect.com/docs Windows and Linux builds are now done on Github Actions, add OSX builds as well Build matrix has been updated to support Python 3.7 through 3.11 for all operating systems for Python distributions Windows portable builds have been moved to Github Actions, signed builds/installer is still done on Appveyor Windows distributions no longer include mkvmerge (can still download for Windows here ) 0.6.1 (November 28, 2022) Release Notes Includes MoviePy support , edge detection capability for fast cuts, and several enhancements/bugfixes. Changelog Command-Line Changes: [feature] Add moviepy backend wrapping the MoviePy package, uses ffmpeg binary on the system for video decoding [feature] Edge detection can now be enabled with detect-content and detect-adaptive to improve accuracy in some cases, especially under lighting changes, see new -w / --weights option for more information A good starting point is to place 100% weight on the change in a frame's hue, 50% on saturation change, 100% on luma (brightness) change, and 25% on change in edges, with a threshold of 32: detect-adaptive -w 1.0 0.5 1.0 0.25 Edge differences are typically larger than other components, so you may need to increase -t / --threshold higher when increasing the edge weight (the last component) with detect-content, for example: detect-content -w 1.0 0.5 1.0 0.25 -t 32` May be enabled by default in the future once it has been more thoroughly tested, further improvements for detect-content are being investigated as well (e.g. motion compensation, flash suppression) Short-form of detect-content option --frame-window has been changed from -w to -f to accommodate this change [enhancement] Progress bar now displays number of detections while processing, no longer conflicts with log message output [enhancement] When using ffmpeg to split videos, -map 0 has been added to the default arguments so other audio tracks are also included when present ( #271 ) [enhancement] Add -a flag to version command to print more information about versions of dependencies/tools being used [enhancement] The resizing method used used for frame downscaling or resizing can now be set using a config file , see [global] option downscale-method and [save-images] option scale-method [other] Linear interpolation is now used as the default downscaling method (previously was nearest neighbor) for improved edge detection accuracy [other] Add -c / --min-content-val argument to detect-adaptive , deprecate -d / --min-delta-hsv General: [general] Recommend detect-adaptive over detect-content [feature] Add new backend VideoStreamMoviePy using the MoviePy package` [feature] Add edge detection to ContentDetector and AdaptiveDetector ( #35 ) Add ability to specify content score weights of hue, saturation, luma, and edge differences between frames Default remains as 1.0, 1.0, 1.0, 0.0 so there is no change in behavior Kernel size used for improving edge overlap can also be customized [feature] AdaptiveDetector no longer requires a StatsManager and can now be used with frame_skip ( #283 ) [bugfix] Fix scenedetect.detect() throwing TypeError when specifying stats_file_path [bugfix] Fix off-by-one error in end event timecode when end_time was set (reported end time was always one extra frame) [bugfix] Fix a named argument that was incorrect ( #299 ) [enhancement] Add optional start_time , end_time , and start_in_scene arguments to scenedetect.detect() ( #282 ) [enhancement] Add -map 0 option to default arguments of split_video_ffmpeg to include all audio tracks by default ( #271 ) [docs] Add example for using a callback ( #273 ) [enhancement] Add new VideoCaptureAdapter to make existing cv2.VideoCapture objects compatible with a SceneManager ( #276 ) Primary use case is for handling input devices/webcams and gstreamer pipes, see updated examples Files, image sequences, and network streams/URLs should continue to use VideoStreamCv2 [api] The SceneManager methods get_cut_list() and get_event_list() are deprecated, along with the base_timecode argument [api] The base_timecode argument of get_scenes_from_cuts() in scenedetect.stats_manager is deprecated (the signature of this function has been changed accordingly) [api] Rename AdaptiveDetector constructor parameter min_delta_hsv to `min_content_val [general] The default crf for split_video_ffmpeg has been changed from 21 to 22 to match command line default [enhancement] Add interpolation property to SceneManager to allow setting method of frame downscaling, use linear interpolation by default (previously nearest neighbor) [enhancement] Add interpolation argument to save_images to allow setting image resize method (default remains bicubic) 0.6 (May 29, 2022) Release Notes PySceneDetect v0.6 is a major breaking change including better performance, configuration file support, and a more ergonomic API. The new minimum Python version is now 3.6 . See the Migration Guide for information on how to port existing applications to the new API. Most users will see performance improvements after updating, and changes to the command-line are not expected to break most workflows. The main goals of v0.6 are reliability and performance. To achieve this required several breaking changes. The video input API was refactored, and many technical debt items were addressed. This should help the eventual transition to the first planned stable release (v1.0) where the goal is an improved scene detection API. Both the Windows installer and portable distributions now include signed executables. Many thanks to SignPath, AppVeyor, and AdvancedInstaller for their support. Changelog Overview: Major performance improvements on multicore systems Configuration file support via command line option or user settings folder Support for multiple video backends, PyAV is now supported in addition to OpenCV Breaking API changes to VideoManager (replaced with VideoStream ), StatsManager , and save_images() See the Migration Guide for details on how to update from v0.5.x A backwards compatibility layer has been added to prevent most applications from breaking, will be removed in a future release Support for Python 2.7 has been dropped, minimum supported Python version is 3.6 Support for OpenCV 2.x has been dropped, minimum OpenCV version is 3.x Windows binaries are now signed, thanks SignPath.io (certificate by SignPath Foundation ) Command-Line Changes: Configuration files are now supported, see documentation for details Can specify config file path with -c / --config , or create a scenedetect.cfg file in your user config folder Frame numbers are now 1-based, aligning with most other tools (e.g. ffmpeg ) and video editors ( #265 ) Start/end frame numbers of adjacent scenes no longer overlap ( #264 ) End/duration timecodes still include the frame's presentation time Add --merge-last-scene option to merge last scene if shorter than --min-scene-len Add -b / --backend option to use a specific video decoding backend Supported backends are opencv and pyav Run scenedetect help to see a list of backends available on the current system Both backends are included with Windows builds split-video command: -c / --copy now uses ffmpeg instead of mkvmerge ( #77 , #236 ) Add -m / --mkvmerge flag to use mkvmerge instead of ffmpeg ( #77 ) Long name for -a has been changed to --args (from --override-args ) detect-adaptive command: --drop-short-scenes now works properly with detect-adaptive detect-content command: Default threshold -t / --threshold lowered to 27 to be more sensitive to shot changes ( #246 ) Add override for global -m / --min-scene-len option detect-threshold command: Remove -p / --min-percent and -b / --block-size options Add override for global -m / --min-scene-len option save-images command now works when -i / --input is an image sequences Default backend (OpenCV) is more robust to video decoder failures -i / --input may no longer be specified multiple times, if required use an external tool (e.g. ffmpeg , mkvmerge ) to perform concatenation before processing -s / --stats no longer loads existing statistics and will overwrite any existing files -l / --logfile now respects -o / --output -v / --verbosity now takes precedence over -q / --quiet API Changes: New detect() function performs scene detection on a video path, see example here New open_video() function to handle video input, see example here split_video_ffmpeg() and split_video_mkvmerge() now take a single path as input save_images() no longer accepts downscale_factor Use scale or height / width arguments to resize images New VideoStream replaces VideoManager ( #213 ) Supports both OpenCV ( VideoStreamCv2 ) and PyAV ( VideoStreamAv ) Improves video seeking invariants, especially around defining what frames 0 and 1 mean for different time properties ( frame_number is 1-based whereas position is 0-based to align with PTS) See test_time_invariants in tests/test_video_stream.py as a reference of specific behaviours Changes to SceneManager : detect_scenes() now performs video decoding in a background thread, improving performance on most systems SceneManager is now responsible for frame downscaling via the downscale / auto_downscale properties detect_scenes() no longer shows a progress bar by default, set show_progress=True to restore the previous behaviour clear() now clears detectors, as they may be stateful get_scene_list() now returns an empty list if there are no detected cuts, specify start_in_scene=True for previous behavior (one scene spanning the entire input) Changes to StatsManager : save_to_csv() now accepts a path or an open file handle base_timecode argument has been removed from save_to_csv() load_from_csv() is now deprecated and will be removed in v1.0 Changes to FrameTimecode : Use rounding instead of truncation when calculating frame numbers to fix incorrect round-trip conversions and improve accuracy ( #268 ) Fix previous_frame() generating negative frame numbers in some cases FrameTimecode objects can now perform arithmetic with formatted strings, e.g. 'HH:MM:SS.nnn' Merged constants MAX_FPS_DELTA and MINIMUM_FRAMES_PER_SECOND_DELTA_FLOAT in scenedetect.frame_timecode into new MAX_FPS_DELTA constant video_manager parameter has been removed from the AdaptiveDetector constructor split_video_ffmpeg and split_video_mkvmerge function arguments have been renamed and defaults updated: suppress_output is now show_output , default is False hide_progress is now show_progress , default is False block_size argument has been removed from the ThresholdDetector constructor calculate_frame_score method of ContentDetector has been renamed to _calculate_frame_score , use new module-level function of the same name instead get_aspect_ratio has been removed from scenedetect.platform (use the aspect_ratio property of a VideoStream instead) Backwards compatibility with v0.5 to avoid breaking most applications on release while still allowing performance improvements Python Distribution Changes v0.6.0.3 - Fix missing package description v0.6.0.2 - Improve error messaging when OpenCV is not installed v0.6.0.1 - Fix original v0.6 release requiring av to run the scenedetect command Known Issues URL inputs are not supported by the save-images or split-video commands Variable framerate videos (VFR) are not fully supported, and will yield incorrect timestamps ( #168 ) The detect-threshold option -l / --add-last-scene cannot be disabled Due to a switch from EXE to MSI for the Windows installer, you may have to uninstall older versions first before installing v0.6 PySceneDetect 0.5 0.5.6.1 (October 11, 2021) Fix crash when using detect-content or detect-adaptive with latest version of OpenCV (thanks @bilde2910) 0.5.6 (August 15, 2021) Release Notes New detection algorithm : detect-adaptive which works similar to detect-content , but with reduced false negatives during fast camera movement (thanks @scarwire and @wjs018) Images generated by save-images can now be resized via the command line Statsfiles now work properly with detect-threshold Removed the -p / --min-percent option from detect-threshold Add new option -l / --luma-only to detect-content / detect-adaptive to only consider brightness channel (useful for greyscale videos) Changelog [feature] New adaptive content detector algorithm detect-adaptive ( #153 , thanks @scarwire and @wjs018) [feature] Images generated with the save-images command ( scene_manager.save_images() function in the Python API) can now be scaled or resized ( #160 and PR #203 , thanks @wjs018) Images can be resized by a constant scaling factory using -s / --scale (e.g. --scale 0.5 shrinks the height/width by half) Images can be resized to a specified height ( -h / --height ) and/or width ( -w / --width ), in pixels; if only one is specified, the aspect ratio of the original video is kept [api] Calling seek() on a VideoManager will now respect the end time if set [api] The split_video_ functions now return the exit code of invoking ffmpeg or mkvmerge ( #209 , thanks @AdrienLF) [api] Removed the min_percent argument from ThresholdDetector as was not providing any performance benefit for the majority of use cases ( #178 ) [bugfix] The detect-threshold command now works properly with a statsfile ( #211 , thanks @jeremymeyers) [bugfix] Fixed crash due to unhandled TypeError exception when using non-PyPI OpenCV packages from certain Linux distributions ( #220 ) [bugfix] A warning is now displayed for videos which may not be decoded correctly, esp. VP9 ( #86 , thanks @wjs018) [api] A named logger is now used for both API and CLI logging instead of the root logger ( #205 ) Known Issues Variable framerate videos (VFR) are not fully supported, and will yield incorrect timestamps ( #168 ) The -l / --add-last-scene option in detect-threshold cannot be disabled Image sequences or URL inputs are not supported by the save-images or split-video commands (in v0.6 save-images works with image sequences) Due to the use of truncation for frame number calculation, FrameTimecode objects may be off-by-one when constructed using a float value ( #268 , fixed in v0.6) 0.5.5 (January 17, 2021) Release Notes One of the last major updates before transitioning to the new v0.6.x API The --min-scene-len / -m option is now global rather than per-detector There is a new global option --drop-short-scenes to go along with -m Removed first row from statsfiles so it is a valid CSV file The progress bar now correctly resizes when the terminal is resized Image sequences and URLs are now supported for input via the CLI/API Images exported using the save-images command are now resized to match the display aspect ratio A new flag -s / --skip-cuts has been added to the list-scenes command to allow standardized processing The functionality of save-images is now accessible via the Python API through the save_images() function in scenedetect.scene_manager Under the save-images command, renamed --image-frame-margin to --frame-margin , added short option -m , and increased the default value from 0 to 1 due to instances of the last frame of a video being occasionally missed (set -m 0 to restore original behaviour) Changelog [bugfix] Allow image sequences and URLs to be used as inputs ( #152 and #188 ) [bugfix] Pixel aspect ratio is now applied when using save-images ( #195 ) [cli] Renamed --image-frame-margin to --frame-margin in save-images command, added short option -m as alias [bugfix] Fix save-images command not saving the last frame by modifying seeking, as well as increasing default of --frame-margin from 0 to 1 [cli] Make --min-scene-len a global option rather than per-detector ( #131 , thanks @tonycpsu) [feature] Added --drop-short-scenes option to remove all scenes smaller than --min-scene-len , instead of merging them [cli] Add -s / --skip-cuts option to list-scenes command to allow outputting a scene list CSV file as compliant with RFC 4180 ( #136 ) [enhancement] Removed first row from statsfile to comply with RFC 4180, includes backwards compatibility so existing statsfiles can still be loaded ( #136 ) [api] Add argument include_cut_list to write_scene_list method in SceneManager to support #136 [api] Removed unused argument base_timecode from StatsManager.load_from_csv() method [api] Make the base_timecode argument optional on the SceneManager methods get_scene_list() , get_cut_list() , and get_event_list() ( #173 ) [api] Support for live video stream callbacks by adding new callback argument to the detect_scenes() method of SceneManager ( #5 , thanks @mhashim6) [bugfix] Fix unhandled exception causing improper error message when a video fails to load on non-Windows platforms ( #192 ) [enhancement] Enabled dynamic resizing for progress bar ( #193 ) [enhancement] Always output version number via logger to assist with debugging ( #171 ) [bugfix] Resolve RuntimeWarning when running as module ( #181 ) [api] Add save_images() function to scenedetect.scene_manager module which exposes the same functionality as the CLI save-images command ( #88 ) [api] Removed close_captures() and release_captures() functions from scenedetect.video_manager module Known Issues Certain non-PyPI OpenCV packages may cause a crash with the message TypeError: isinstance() arg 2 must be a type or tuple of types - as a workaround, install the Python OpenCV package by running pip install scenedetect[opencv] ( #220 ) Image sequences or URL inputs are not supported by the save-images or split-video commands Variable framerate videos (VFR) are not fully supported, and will yield incorrect timestamps ( #168 ) 0.5.4 (September 14, 2020) Release Notes Improved performance when using time and save-images commands Improved performance of detect-threshold when using a small minimum percent Fix crash when using detect-threshold with a statsfile Fix crash when using save-images command under Python 2.7 Support for Python 3.3 and 3.4 has been deprecated (see below) Changelog [bugfix] fix detect-threshold crash when using statsfile ( #122 ) [bugfix] fix save-images command under Python 2.7 ( #174 , thanks @santiagodemierre) [bugfix] gracefully exit and show link to FAQ when number of scenes is too large to split with mkvmerge on Windows (see #164 [enhancement] Improved seeking performance, greatly improves performance of the time and save-images commands ( #98 and PR #163 - thanks @obroomhall) [enhancement] improve detect-threshold performance when min-percent is less than 50% [bugfix] Fixed issue where video loading would fail silently due to multiple audio tracks ( #179 ) [general] Made tqdm a regular requirement and not an extra ( #180 ) [general] Support for Python 3.3 and 3.4 has been deprecated. Newer builds may still work on these Python versions, but future releases are not tested against these versions. This decision was made as part of #180 Known Issues Variable framerate videos are not supported properly currently (#168), a warning may be added in the next release to indicate when a VFR video is detected, until this can be properly resolved ( #168 ) 0.5.3 (July 12, 2020) Release Notes Resolved long-standing bug where split-video command would duplicate certain frames at the beginning/end of the output ( #93 ) This was determined to be caused by copying (instead of re-encoding) the audio track, causing extra frames to be brought in when the audio samples did not line up on a frame boundary (thank you @joshcoales for your assistance) Default behavior is to now re-encode audio tracks using the aac codec when using split-video (it can be overridden in both the command line and Python interface) Improved timestamp accuracy when using split-video command to further reduce instances of duplicated or off-by-one frame issues Fixed application crash when using the -l / --logfile argument Changelog [bugfix] Changed default audio codec from 'copy' to 'aac' when splitting scenes with ffmpeg to reduce frequency of frames from next scene showing up at the end of the current one when split using ffmpeg (see #93 , #159 , and PR #166 - thank you everyone for your assistance, especially joshcoales, amvscenes, jelias, and typoman). If this still occurs, please provide any information you can by filing a new issue on Github . [enhancement] video_splitter module now has completed documentation [bugfix] improve timestamp accuracy using the split-video command due to timecode formatting [bugfix] fix crash when supplying -l / --logfile argument (see #169 , thanks @typoman) Known Issues Seeking through long videos is inefficient, causing the time and save-images command to take a long time to run. This will be resolved in the next release (see #98 ) The save-images command causes PySceneDetect to crash under Python 2.7 (see #174 ) Using detect-threshold with a statsfile causes PySceneDetect to crash (see #122 ) Variable framerate videos are not supported properly currently (#168), a warning may be added in the next release to indicate when a VFR video is detected, until this can be properly resolved ( #168 ) Videos with multiple audio tracks may not work correctly, see this comment on #179 for a workaround using ffmpeg or mkvmerge 0.5.2 (March 29, 2020) [enhancement] --min-duration now accepts a timecode in addition to frame number ( #128 , thanks @tonycpsu) [feature] Add --image-frame-margin option to save-images command to ignore a number of frames at the start/end of a scene ( #129 , thanks @tonycpsu) [bugfix] --min-scene-len option was not respected by first scene ( #105 , thanks @charlesvestal) [bugfix] Splitting videos with an analyzed duration only splits within analyzed area ( #106 , thanks @charlesvestal) [bugfix] Improper start timecode applied to the split-video command when using ffmpeg ( #93 , thanks @typoman) [bugfix] Added links and filename sanitation to html output ( #139 and #140 , thanks @wjs018) [bugfix] UnboundLocalError in detect_scenes when frame_skip is larger than 0 ( #126 , thanks @twostarxx) 0.5.1.1 (August 3, 2019) minor re-release of v0.5.1 which updates the setup.py file to return OpenCV as an optional dependency to install from pip now with all dependencies: pip install scenedetect[opencv,progress_bar] to install only PySceneDetect: pip install scenedetect (separate OpenCV installation required) the release notes of v0.5.1 have been modified to include the prior command no change to PySceneDetect program version [feature] add get_duration method to VideoManager ( #109 , thanks @arianaa30) 0.5.1 (July 20, 2019) [feature] Add new export-html command to the CLI (thanks @wjs018 ) [bugfix] VideoManager read function failed on multiple videos (thanks @ivan23kor ) [bugfix] Fix crash when no scenes are detected ( #79 , thanks @raj6996) [bugfix] Fixed OpenCV not getting installed due to missing dependency ( #73 ) [enhance] When no scenes are detected, the whole video is now returned instead of nothing (thanks @piercus ) Removed Windows installer due to binary packages now being available, and to streamline the release process (see #102 for more information). When you type pip install scenedetect[opencv,progress_bar] , all dependencies will be installed. 0.5 (August 31, 2018) major release, includes stable Python API with examples and updated documentation numerous changes to command-line interface with addition of sub-commands (see the new manual for updated usage information) [feature] videos are now split using ffmpeg by default, resulting in frame-perfect cuts (can still use mkvmerge by specifying the -c / --copy argument to the split-video command) [enhance] image filename numbers are now consistent with those of split video scenes (PR #39, thanks @e271828- ) [enhance] 5-10% improvement in processing performance due to reduced memory copy operations (PR #40, thanks @elcombato ) [enhance] updated exception handling to raise proper standard exceptions (PR #37, thanks @talkain ) several fixes to the documentation, including improper dates and outdated CLI arguments (PR #26 and #, thanks @elcombato , and @colelawrence ) numerous other PRs and issues/bug reports that have been fixed - there are too many to list individually here, so I want to extend a big thank you to everyone who contributed to making this release better [enhance] add Sphinx-generated API documentation (available at: http://manual.scenedetect.com) [project] move from BSD 2-clause to 3-clause license PySceneDetect 0.4 0.4 (January 14, 2017) major release, includes integrated scene splitting via mkvmerge, changes meaning of -o / --output option [feature] specifying -o OUTPUT_FILE.mkv will now automatically split the input video, generating a new video clip for each detected scene in sequence, starting with OUTPUT_FILE-001.mkv [enhance] CSV file output is now specified with the -co / --csv-output option ( note, used to be -o in versions of PySceneDetect < 0.4 ) PySceneDetect 0.3-beta 0.3.6 (January 12, 2017) [enhance] performance improvement when using --frameskip option (thanks @marcelluzs ) [internal] moved application state and shared objects to a consistent interface (the SceneManager object) to greatly reduce the number of required arguments for certain API functions [enhance] added installer for Windows builds (64-bit only currently) 0.3.5 (August 2, 2016) [enhance] initial release of portable build for Windows (64-bit only), including all dependencies [bugfix] fix unrelated exception thrown when video could not be loaded (thanks @marcelluzs ) [internal] fix variable name typo in API documentation 0.3.4 (February 8, 2016) [enhance] add scene length, in seconds, to output file ( -o ) for easier integration with ffmpeg / libav [enhance] improved performance of content detection mode by caching intermediate HSV frames in memory (approx. 2x faster) [enhance] show timecode values in terminal when using extended output ( -l ) [feature] add fade bias option ( -fb / --fade-bias ) to command line (threshold mode only) 0.3.3 (January 27, 2016) [bugfix] output scenes are now correctly written to specified output file when using -o flag (fixes #11) [bugfix] fix indexing exception when using multiple scene detectors and outputting statistics [internal] distribute package on PyPI, version move from beta to stable [internal] add function to convert frame number to formatted timecode [internal] move file and statistic output to Python csv module 0.3.2-beta (January 26, 2016) [feature] added -si / --save-images flag to enable saving the first and last frames of each detected scene as an image, saved in the current working directory with the original video filename as the output prefix [feature] added command line options for setting start and end times for processing ( -st and -et ) [feature] added command line option to specify maximum duration to process ( -dt , overrides -et ) 0.3.1-beta (January 23, 2016) [feature] added downscaling/subsampling option ( -df / --downscale-factor ) to improve performance on higher resolution videos [feature] added frameskip option ( -fs / --frame-skip ) to improve performance on high framerate videos, at expense of frame accuracy and possible inaccurate scene cut prediction [enhance] added setup.py to allow for one-line installation (just run python setup.py install after downloading and extracting PySceneDetect) [internal] additional API functions to remove requirement on passing OpenCV video objects, and allow just a file path instead 0.3-beta (January 8, 2016) major release, includes improved detection algorithms and complete internal code refactor [feature] content-aware scene detection using HSV-colourspace based algorithm (use -d content ) [enhance] added CLI flags to allow user changes to more algorithm properties [internal] re-implemented threshold-based scene detection algorithm under new interface [internal] major code refactor including standard detection algorithm interface and API [internal] remove statistics mode until update to new detection mode interface PySceneDetect 0.2-alpha 0.2.4-alpha (December 22, 2015) [bugfix] updated OpenCV compatibility with self-reported version on some Linux distributions 0.2.3-alpha (August 7, 2015) [bugfix] updated PySceneDetect to work with latest OpenCV module (ver > 3.0) [bugfix] added compatibility/legacy code for older versions of OpenCV [feature] statsfile generation includes expanded frame metrics 0.2.2-alpha (November 25, 2014) [feature] added statistics mode for generating frame-by-frame analysis (-s / --statsfile flag) [bugfix] fixed improper timecode conversion 0.2.1-alpha (November 16, 2014) [enhance] proper timecode format (HH:MM:SS.nnnnn) [enhance] one-line of CSV timecodes added for easy splitting with external tool 0.2-alpha (June 9, 2014) [enhance] now provides discrete scene list (in addition to fades) [feature] ability to output to file (-o / --output flag) PySceneDetect 0.1-alpha 0.1-alpha (June 8, 2014) first public release [feature] threshold-based fade in/out detection Development PySceneDetect 0.6.6 (In Development) [bugfix] Fix crash when using split-video with -m / --mkvmerge option #473 [bugfix] Fix incorrect default filename template for split-video command with -m / --mkvmerge option [bugfix] Fix inconsistent filenames when using split_video_mkvmerge() function in scenedetect.video_splitter module","title":"Changelog"},{"location":"changelog/#releases","text":"","title":"Releases"},{"location":"changelog/#pyscenedetect-06","text":"","title":"PySceneDetect 0.6"},{"location":"changelog/#pyscenedetect-065-november-24-2024","text":"","title":"PySceneDetect 0.6.5 (November 24, 2024)"},{"location":"changelog/#release-notes","text":"This release brings crop support, performance improvements to save-images, lots of bugfixes, and improved compatibility with MoviePy 2.0+.","title":"Release Notes"},{"location":"changelog/#changelog","text":"[feature] Add ability to crop input video before processing #302 #449 [cli] Add --crop option to scenedetect command and config file to crop video frames before scene detection [api] Add crop property to SceneManager to crop video frames before scene detection [feature] Add ability to configure CSV separators for rows/columns in config file #423 [feature] Add new --show flag to export-html command to launch browser after processing #442 [improvement] Add new threading option to save-images / save_images() #456 Enabled by default, offloads image encoding and disk IO to separate threads Improves performance by up to 50% in some cases [improvement] The export-html command now implicitly invokes save-images with default parameters The output of the export-html command will always use the result of the save-images command that precedes it [improvement] save_to_csv now works with paths from pathlib [api] The save_to_csv function now works correctly with paths from the pathlib module [api] Add col_separator and row_separator args to write_scene_list function in scenedetect.scene_manager [api] The MoviePy backend now works with MoviePy 2.0+ [bugfix] Fix SyntaxWarning due to incorrect escaping #400 [bugfix] Fix ContentDetector crash when using callbacks #416 #420 [bugfix] Fix save-images / save_images() not working correctly with UTF-8 paths #450 [bugfix] Fix crash when using save-images / save_images() with OpenCV backend #455 [bugfix] Fix new detectors not working with default-detector config option [general] Timecodes of the form MM:SS[.nnn] are now processed correctly #443 [general] Updates to Windows distributions: The MoviePy backend is now included with Windows distributions Python 3.9 -> Python 3.13 PyAV 10 -> 13.1.0 OpenCV 4.10.0.82 -> 4.10.0.84 Ffmpeg 6.0 -> 7.1","title":"Changelog"},{"location":"changelog/#python-distribution-changes","text":"v0.6.5.1 - Fix compatibility issues with PyAV 14+ #466 v0.6.5.2 - Fix for AttributeError: module 'cv2' has no attribute 'Mat' #468","title":"Python Distribution Changes"},{"location":"changelog/#064-june-10-2024","text":"","title":"0.6.4 (June 10, 2024)"},{"location":"changelog/#release-notes_1","text":"Includes new histogram and perceptual hash based detectors (thanks @wjs018 and @ash2703), adds flash filter to content detector, and includes various bugfixes. Below shows the scores of the new detectors normalized against detect-content for comparison on a difficult segment with 3 cuts: Feedback on the new detection methods and their default values is most welcome. Thanks to everyone who contributed for their help and support!","title":"Release Notes"},{"location":"changelog/#changelog_1","text":"[feature] New detectors: detect-hist / HistogramDetector #295 #53 detect-hash / HashDetector #290 [feature] Add flash suppression filter for detect-content / ContentDetector (enabled by default) #35 #53 Reduces number of cuts generated during strobing or flashing effects Can be configured using --filter-mode option --filter-mode = merge (new default) merges consecutive scenes shorter than min-scene-len --filter-mode = suppress (previous default) disables generating new scenes until min-scene-len has passed [feature] Add more templates for save-images filename customization: $TIMECODE , $FRAME_NUMBER , $TIMESTAMP_MS (thanks @Veldhoen0) #395 [bugfix] Remove extraneous console output when using --drop-short-scenes [bugfix] Fix scene lengths being smaller than min-scene-len when using detect-adaptive / AdaptiveDetector with large values of --frame-window [bugfix] Fix crash when decoded frames have incorrect resolution and log error instead #319 [bugfix] Update default ffmpeg stream mapping from -map 0 to -map 0:v:0 -map 0:a? -map 0:s? #392","title":"Changelog"},{"location":"changelog/#063-march-9-2024","text":"","title":"0.6.3 (March 9, 2024)"},{"location":"changelog/#release-notes_2","text":"In addition to some perfromance improvements with the load-scenes command, this release of PySceneDetect includes a significant amount of bugfixes. Thanks to everyone who contributed to the release, including those who filed bug reports and helped with debugging! Program Changes: [bugfix] Fix crash for some WebM videos when using save-images with --backend pyav #355 [bugfix] Correct --duration and --end for presentation time when specified as frame numbers #341 [bugfix] Progress bar now has correct frame accounting when --duration or --end are set #341 [bugfix] Only allow load-scenes to be specified once, and disallow with other detect-* commands #347 [bugfix] Disallow -s / --start being larger than -e / --end for the time command [bugfix] Fix detect-adaptive not respecting --min-scene-len for the first scene [general] Comma-separated timecode list is now only printed when the list-scenes command is specified #356 [general] Several changes to [list-scenes] config file options: Add display-scenes and display-cuts options to control output Add cut-format to control formatting of cut points #349 Valid values: frames , timecode , seconds [general] Increase progress bar indent to improve visibility and visual alignment [improvement] The s suffix for setting timecode values in seconds is no longer required (values without decimal places are still interpreted as frame numbers) [improvement] load-scenes now skips detection, generating output much faster #347 (thanks @wjs018 for the initial implementation) API Changes: [bugfix] Fix AttributeError thrown when accessing aspect_ratio on certain videos using VideoStreamAv #355 [bugfix] Fix circular imports due to partially initialized module for some development environments #350 [bugfix] Fix SceneManager.detect_scenes warning when duration or end_time are specified as timecode strings #346 [bugfix] Ensure correct string conversion behavior for FrameTimecode when rounding is enabled #354 [bugfix] Fix AdaptiveDetector not respecting min_scene_len for the first scene [feature] Add output_dir argument to split_video_ffmpeg and split_video_mkvmerge functions to set output directory #298 [feature] Add formatter argument to split_video_ffmpeg to allow formatting filenames via callback #359 [general] The frame_img argument to SceneDetector.process_frame() is now required [general] Remove TimecodeValue from scenedetect.frame_timecode (use typing.Union[int, float, str] ) [general] Remove MotionDetector and scenedetect.detectors.motion_detector module (will be reintroduced after SceneDetector interface is stable) [improvement] scenedetect.stats_manager module improvements: The StatsManager.register_metrics() method no longer throws any exceptions Add StatsManager.metric_keys property to query registered metric keys Deprecate FrameMetricRegistered and FrameMetricNotRegistered exceptions (no longer used) [improvement] When converting strings representing seconds to FrameTimecode , the s suffix is now optional, and whitespace is ignored (note that values without decimal places are still interpreted as frame numbers) [improvement] The VideoCaptureAdapter in scenedetect.backends.opencv now attempts to report duration if known","title":"Release Notes"},{"location":"changelog/#062-july-23-2023","text":"","title":"0.6.2 (July 23, 2023)"},{"location":"changelog/#release-notes_3","text":"Includes new load-scenes command , ability to specify a default detector, PyAV 10 support, and several bugfixes. Minimum supported Python version is now Python 3.7 . Command-Line Changes: [feature] Add load-scenes command to load cuts from list-scenes CSV output #235 [feature] Use detect-adaptive by default if a detector is not specified #329 Default detector can be set by config file with the default-detector option under [global] [bugfix] Fix -d / --duration and -e / --end options of time command consuming one extra frame #307 [bugfix] Fix incorrect end timecode for final scene when last frame of video is a new scene #307 [bugfix] Expand $VIDEO_NAME before creating output directory for -f / --filename option of split-video , now allows absolute paths [general] Rename ThresholdDetector ( detect-threshold ) metric delta_rgb metric to average_rgb [general] -l / --logfile always produces debug logs now [general] Remove -a / --all flag from scenedetect version command, now prints all information by default (can still call scenedetect for version number alone) [general] Add -h / --help options globally and for each command [general] Remove all option from scenedetect help command (can now call scenedetect help for full reference) General: [feature] Add ability to specify method (floor/ceiling) when creating ThresholdDetector , allows fade to white detection #143 [general] Minimum supported Python version is now Python 3.7 [general] Add support for PyAV 10.0 #292 [general] Use platformdirs package instead of appdirs #309 [bugfix] Fix end_time always consuming one extra frame #307 [bugfix] Fix incorrect end timecode for last scene when start_in_scene is True or the final scene contains a single frame #307 [bugfix] Fix MoviePy read next frame #320 [bugfix] Template replacement when generating output now allows lower-case letters to be used as separators in addition to other characters [api] Make some public functions/methods private (prefixed with _ ): get_aspect_ratio function in scenedetect.backends.opencv mean_pixel_distance and estimated_kernel_size functions in scenedetect.detectors.content_detector compute_frame_average function in scenedetect.detectors.threshold_detector scenedetect.cli and scenedetect.thirdparty modules [api] Remove compute_downscale_factor in scenedetect.video_stream (use scenedetect.scene_manager.compute_downscale_factor instead) [dist] Updated dependencies in Windows distributions: ffmpeg 6.0, PyAV 10, OpenCV 4.8, removed mkvmerge","title":"Release Notes"},{"location":"changelog/#project-updates","text":"Website and documentation is now hosted on Github Pages, documentation can be found at scenedetect.com/docs Windows and Linux builds are now done on Github Actions, add OSX builds as well Build matrix has been updated to support Python 3.7 through 3.11 for all operating systems for Python distributions Windows portable builds have been moved to Github Actions, signed builds/installer is still done on Appveyor Windows distributions no longer include mkvmerge (can still download for Windows here )","title":"Project Updates"},{"location":"changelog/#061-november-28-2022","text":"","title":"0.6.1 (November 28, 2022)"},{"location":"changelog/#release-notes_4","text":"Includes MoviePy support , edge detection capability for fast cuts, and several enhancements/bugfixes.","title":"Release Notes"},{"location":"changelog/#changelog_2","text":"Command-Line Changes: [feature] Add moviepy backend wrapping the MoviePy package, uses ffmpeg binary on the system for video decoding [feature] Edge detection can now be enabled with detect-content and detect-adaptive to improve accuracy in some cases, especially under lighting changes, see new -w / --weights option for more information A good starting point is to place 100% weight on the change in a frame's hue, 50% on saturation change, 100% on luma (brightness) change, and 25% on change in edges, with a threshold of 32: detect-adaptive -w 1.0 0.5 1.0 0.25 Edge differences are typically larger than other components, so you may need to increase -t / --threshold higher when increasing the edge weight (the last component) with detect-content, for example: detect-content -w 1.0 0.5 1.0 0.25 -t 32` May be enabled by default in the future once it has been more thoroughly tested, further improvements for detect-content are being investigated as well (e.g. motion compensation, flash suppression) Short-form of detect-content option --frame-window has been changed from -w to -f to accommodate this change [enhancement] Progress bar now displays number of detections while processing, no longer conflicts with log message output [enhancement] When using ffmpeg to split videos, -map 0 has been added to the default arguments so other audio tracks are also included when present ( #271 ) [enhancement] Add -a flag to version command to print more information about versions of dependencies/tools being used [enhancement] The resizing method used used for frame downscaling or resizing can now be set using a config file , see [global] option downscale-method and [save-images] option scale-method [other] Linear interpolation is now used as the default downscaling method (previously was nearest neighbor) for improved edge detection accuracy [other] Add -c / --min-content-val argument to detect-adaptive , deprecate -d / --min-delta-hsv General: [general] Recommend detect-adaptive over detect-content [feature] Add new backend VideoStreamMoviePy using the MoviePy package` [feature] Add edge detection to ContentDetector and AdaptiveDetector ( #35 ) Add ability to specify content score weights of hue, saturation, luma, and edge differences between frames Default remains as 1.0, 1.0, 1.0, 0.0 so there is no change in behavior Kernel size used for improving edge overlap can also be customized [feature] AdaptiveDetector no longer requires a StatsManager and can now be used with frame_skip ( #283 ) [bugfix] Fix scenedetect.detect() throwing TypeError when specifying stats_file_path [bugfix] Fix off-by-one error in end event timecode when end_time was set (reported end time was always one extra frame) [bugfix] Fix a named argument that was incorrect ( #299 ) [enhancement] Add optional start_time , end_time , and start_in_scene arguments to scenedetect.detect() ( #282 ) [enhancement] Add -map 0 option to default arguments of split_video_ffmpeg to include all audio tracks by default ( #271 ) [docs] Add example for using a callback ( #273 ) [enhancement] Add new VideoCaptureAdapter to make existing cv2.VideoCapture objects compatible with a SceneManager ( #276 ) Primary use case is for handling input devices/webcams and gstreamer pipes, see updated examples Files, image sequences, and network streams/URLs should continue to use VideoStreamCv2 [api] The SceneManager methods get_cut_list() and get_event_list() are deprecated, along with the base_timecode argument [api] The base_timecode argument of get_scenes_from_cuts() in scenedetect.stats_manager is deprecated (the signature of this function has been changed accordingly) [api] Rename AdaptiveDetector constructor parameter min_delta_hsv to `min_content_val [general] The default crf for split_video_ffmpeg has been changed from 21 to 22 to match command line default [enhancement] Add interpolation property to SceneManager to allow setting method of frame downscaling, use linear interpolation by default (previously nearest neighbor) [enhancement] Add interpolation argument to save_images to allow setting image resize method (default remains bicubic)","title":"Changelog"},{"location":"changelog/#06-may-29-2022","text":"","title":"0.6 (May 29, 2022)"},{"location":"changelog/#release-notes_5","text":"PySceneDetect v0.6 is a major breaking change including better performance, configuration file support, and a more ergonomic API. The new minimum Python version is now 3.6 . See the Migration Guide for information on how to port existing applications to the new API. Most users will see performance improvements after updating, and changes to the command-line are not expected to break most workflows. The main goals of v0.6 are reliability and performance. To achieve this required several breaking changes. The video input API was refactored, and many technical debt items were addressed. This should help the eventual transition to the first planned stable release (v1.0) where the goal is an improved scene detection API. Both the Windows installer and portable distributions now include signed executables. Many thanks to SignPath, AppVeyor, and AdvancedInstaller for their support.","title":"Release Notes"},{"location":"changelog/#changelog_3","text":"Overview: Major performance improvements on multicore systems Configuration file support via command line option or user settings folder Support for multiple video backends, PyAV is now supported in addition to OpenCV Breaking API changes to VideoManager (replaced with VideoStream ), StatsManager , and save_images() See the Migration Guide for details on how to update from v0.5.x A backwards compatibility layer has been added to prevent most applications from breaking, will be removed in a future release Support for Python 2.7 has been dropped, minimum supported Python version is 3.6 Support for OpenCV 2.x has been dropped, minimum OpenCV version is 3.x Windows binaries are now signed, thanks SignPath.io (certificate by SignPath Foundation ) Command-Line Changes: Configuration files are now supported, see documentation for details Can specify config file path with -c / --config , or create a scenedetect.cfg file in your user config folder Frame numbers are now 1-based, aligning with most other tools (e.g. ffmpeg ) and video editors ( #265 ) Start/end frame numbers of adjacent scenes no longer overlap ( #264 ) End/duration timecodes still include the frame's presentation time Add --merge-last-scene option to merge last scene if shorter than --min-scene-len Add -b / --backend option to use a specific video decoding backend Supported backends are opencv and pyav Run scenedetect help to see a list of backends available on the current system Both backends are included with Windows builds split-video command: -c / --copy now uses ffmpeg instead of mkvmerge ( #77 , #236 ) Add -m / --mkvmerge flag to use mkvmerge instead of ffmpeg ( #77 ) Long name for -a has been changed to --args (from --override-args ) detect-adaptive command: --drop-short-scenes now works properly with detect-adaptive detect-content command: Default threshold -t / --threshold lowered to 27 to be more sensitive to shot changes ( #246 ) Add override for global -m / --min-scene-len option detect-threshold command: Remove -p / --min-percent and -b / --block-size options Add override for global -m / --min-scene-len option save-images command now works when -i / --input is an image sequences Default backend (OpenCV) is more robust to video decoder failures -i / --input may no longer be specified multiple times, if required use an external tool (e.g. ffmpeg , mkvmerge ) to perform concatenation before processing -s / --stats no longer loads existing statistics and will overwrite any existing files -l / --logfile now respects -o / --output -v / --verbosity now takes precedence over -q / --quiet API Changes: New detect() function performs scene detection on a video path, see example here New open_video() function to handle video input, see example here split_video_ffmpeg() and split_video_mkvmerge() now take a single path as input save_images() no longer accepts downscale_factor Use scale or height / width arguments to resize images New VideoStream replaces VideoManager ( #213 ) Supports both OpenCV ( VideoStreamCv2 ) and PyAV ( VideoStreamAv ) Improves video seeking invariants, especially around defining what frames 0 and 1 mean for different time properties ( frame_number is 1-based whereas position is 0-based to align with PTS) See test_time_invariants in tests/test_video_stream.py as a reference of specific behaviours Changes to SceneManager : detect_scenes() now performs video decoding in a background thread, improving performance on most systems SceneManager is now responsible for frame downscaling via the downscale / auto_downscale properties detect_scenes() no longer shows a progress bar by default, set show_progress=True to restore the previous behaviour clear() now clears detectors, as they may be stateful get_scene_list() now returns an empty list if there are no detected cuts, specify start_in_scene=True for previous behavior (one scene spanning the entire input) Changes to StatsManager : save_to_csv() now accepts a path or an open file handle base_timecode argument has been removed from save_to_csv() load_from_csv() is now deprecated and will be removed in v1.0 Changes to FrameTimecode : Use rounding instead of truncation when calculating frame numbers to fix incorrect round-trip conversions and improve accuracy ( #268 ) Fix previous_frame() generating negative frame numbers in some cases FrameTimecode objects can now perform arithmetic with formatted strings, e.g. 'HH:MM:SS.nnn' Merged constants MAX_FPS_DELTA and MINIMUM_FRAMES_PER_SECOND_DELTA_FLOAT in scenedetect.frame_timecode into new MAX_FPS_DELTA constant video_manager parameter has been removed from the AdaptiveDetector constructor split_video_ffmpeg and split_video_mkvmerge function arguments have been renamed and defaults updated: suppress_output is now show_output , default is False hide_progress is now show_progress , default is False block_size argument has been removed from the ThresholdDetector constructor calculate_frame_score method of ContentDetector has been renamed to _calculate_frame_score , use new module-level function of the same name instead get_aspect_ratio has been removed from scenedetect.platform (use the aspect_ratio property of a VideoStream instead) Backwards compatibility with v0.5 to avoid breaking most applications on release while still allowing performance improvements","title":"Changelog"},{"location":"changelog/#python-distribution-changes_1","text":"v0.6.0.3 - Fix missing package description v0.6.0.2 - Improve error messaging when OpenCV is not installed v0.6.0.1 - Fix original v0.6 release requiring av to run the scenedetect command","title":"Python Distribution Changes"},{"location":"changelog/#known-issues","text":"URL inputs are not supported by the save-images or split-video commands Variable framerate videos (VFR) are not fully supported, and will yield incorrect timestamps ( #168 ) The detect-threshold option -l / --add-last-scene cannot be disabled Due to a switch from EXE to MSI for the Windows installer, you may have to uninstall older versions first before installing v0.6","title":"Known Issues"},{"location":"changelog/#pyscenedetect-05","text":"","title":"PySceneDetect 0.5"},{"location":"changelog/#0561-october-11-2021","text":"Fix crash when using detect-content or detect-adaptive with latest version of OpenCV (thanks @bilde2910)","title":"0.5.6.1 (October 11, 2021)"},{"location":"changelog/#056-august-15-2021","text":"","title":"0.5.6 (August 15, 2021)"},{"location":"changelog/#release-notes_6","text":"New detection algorithm : detect-adaptive which works similar to detect-content , but with reduced false negatives during fast camera movement (thanks @scarwire and @wjs018) Images generated by save-images can now be resized via the command line Statsfiles now work properly with detect-threshold Removed the -p / --min-percent option from detect-threshold Add new option -l / --luma-only to detect-content / detect-adaptive to only consider brightness channel (useful for greyscale videos)","title":"Release Notes"},{"location":"changelog/#changelog_4","text":"[feature] New adaptive content detector algorithm detect-adaptive ( #153 , thanks @scarwire and @wjs018) [feature] Images generated with the save-images command ( scene_manager.save_images() function in the Python API) can now be scaled or resized ( #160 and PR #203 , thanks @wjs018) Images can be resized by a constant scaling factory using -s / --scale (e.g. --scale 0.5 shrinks the height/width by half) Images can be resized to a specified height ( -h / --height ) and/or width ( -w / --width ), in pixels; if only one is specified, the aspect ratio of the original video is kept [api] Calling seek() on a VideoManager will now respect the end time if set [api] The split_video_ functions now return the exit code of invoking ffmpeg or mkvmerge ( #209 , thanks @AdrienLF) [api] Removed the min_percent argument from ThresholdDetector as was not providing any performance benefit for the majority of use cases ( #178 ) [bugfix] The detect-threshold command now works properly with a statsfile ( #211 , thanks @jeremymeyers) [bugfix] Fixed crash due to unhandled TypeError exception when using non-PyPI OpenCV packages from certain Linux distributions ( #220 ) [bugfix] A warning is now displayed for videos which may not be decoded correctly, esp. VP9 ( #86 , thanks @wjs018) [api] A named logger is now used for both API and CLI logging instead of the root logger ( #205 )","title":"Changelog"},{"location":"changelog/#known-issues_1","text":"Variable framerate videos (VFR) are not fully supported, and will yield incorrect timestamps ( #168 ) The -l / --add-last-scene option in detect-threshold cannot be disabled Image sequences or URL inputs are not supported by the save-images or split-video commands (in v0.6 save-images works with image sequences) Due to the use of truncation for frame number calculation, FrameTimecode objects may be off-by-one when constructed using a float value ( #268 , fixed in v0.6)","title":"Known Issues"},{"location":"changelog/#055-january-17-2021","text":"","title":"0.5.5 (January 17, 2021)"},{"location":"changelog/#release-notes_7","text":"One of the last major updates before transitioning to the new v0.6.x API The --min-scene-len / -m option is now global rather than per-detector There is a new global option --drop-short-scenes to go along with -m Removed first row from statsfiles so it is a valid CSV file The progress bar now correctly resizes when the terminal is resized Image sequences and URLs are now supported for input via the CLI/API Images exported using the save-images command are now resized to match the display aspect ratio A new flag -s / --skip-cuts has been added to the list-scenes command to allow standardized processing The functionality of save-images is now accessible via the Python API through the save_images() function in scenedetect.scene_manager Under the save-images command, renamed --image-frame-margin to --frame-margin , added short option -m , and increased the default value from 0 to 1 due to instances of the last frame of a video being occasionally missed (set -m 0 to restore original behaviour)","title":"Release Notes"},{"location":"changelog/#changelog_5","text":"[bugfix] Allow image sequences and URLs to be used as inputs ( #152 and #188 ) [bugfix] Pixel aspect ratio is now applied when using save-images ( #195 ) [cli] Renamed --image-frame-margin to --frame-margin in save-images command, added short option -m as alias [bugfix] Fix save-images command not saving the last frame by modifying seeking, as well as increasing default of --frame-margin from 0 to 1 [cli] Make --min-scene-len a global option rather than per-detector ( #131 , thanks @tonycpsu) [feature] Added --drop-short-scenes option to remove all scenes smaller than --min-scene-len , instead of merging them [cli] Add -s / --skip-cuts option to list-scenes command to allow outputting a scene list CSV file as compliant with RFC 4180 ( #136 ) [enhancement] Removed first row from statsfile to comply with RFC 4180, includes backwards compatibility so existing statsfiles can still be loaded ( #136 ) [api] Add argument include_cut_list to write_scene_list method in SceneManager to support #136 [api] Removed unused argument base_timecode from StatsManager.load_from_csv() method [api] Make the base_timecode argument optional on the SceneManager methods get_scene_list() , get_cut_list() , and get_event_list() ( #173 ) [api] Support for live video stream callbacks by adding new callback argument to the detect_scenes() method of SceneManager ( #5 , thanks @mhashim6) [bugfix] Fix unhandled exception causing improper error message when a video fails to load on non-Windows platforms ( #192 ) [enhancement] Enabled dynamic resizing for progress bar ( #193 ) [enhancement] Always output version number via logger to assist with debugging ( #171 ) [bugfix] Resolve RuntimeWarning when running as module ( #181 ) [api] Add save_images() function to scenedetect.scene_manager module which exposes the same functionality as the CLI save-images command ( #88 ) [api] Removed close_captures() and release_captures() functions from scenedetect.video_manager module","title":"Changelog"},{"location":"changelog/#known-issues_2","text":"Certain non-PyPI OpenCV packages may cause a crash with the message TypeError: isinstance() arg 2 must be a type or tuple of types - as a workaround, install the Python OpenCV package by running pip install scenedetect[opencv] ( #220 ) Image sequences or URL inputs are not supported by the save-images or split-video commands Variable framerate videos (VFR) are not fully supported, and will yield incorrect timestamps ( #168 )","title":"Known Issues"},{"location":"changelog/#054-september-14-2020","text":"","title":"0.5.4 (September 14, 2020)"},{"location":"changelog/#release-notes_8","text":"Improved performance when using time and save-images commands Improved performance of detect-threshold when using a small minimum percent Fix crash when using detect-threshold with a statsfile Fix crash when using save-images command under Python 2.7 Support for Python 3.3 and 3.4 has been deprecated (see below)","title":"Release Notes"},{"location":"changelog/#changelog_6","text":"[bugfix] fix detect-threshold crash when using statsfile ( #122 ) [bugfix] fix save-images command under Python 2.7 ( #174 , thanks @santiagodemierre) [bugfix] gracefully exit and show link to FAQ when number of scenes is too large to split with mkvmerge on Windows (see #164 [enhancement] Improved seeking performance, greatly improves performance of the time and save-images commands ( #98 and PR #163 - thanks @obroomhall) [enhancement] improve detect-threshold performance when min-percent is less than 50% [bugfix] Fixed issue where video loading would fail silently due to multiple audio tracks ( #179 ) [general] Made tqdm a regular requirement and not an extra ( #180 ) [general] Support for Python 3.3 and 3.4 has been deprecated. Newer builds may still work on these Python versions, but future releases are not tested against these versions. This decision was made as part of #180","title":"Changelog"},{"location":"changelog/#known-issues_3","text":"Variable framerate videos are not supported properly currently (#168), a warning may be added in the next release to indicate when a VFR video is detected, until this can be properly resolved ( #168 )","title":"Known Issues"},{"location":"changelog/#053-july-12-2020","text":"","title":"0.5.3 (July 12, 2020)"},{"location":"changelog/#release-notes_9","text":"Resolved long-standing bug where split-video command would duplicate certain frames at the beginning/end of the output ( #93 ) This was determined to be caused by copying (instead of re-encoding) the audio track, causing extra frames to be brought in when the audio samples did not line up on a frame boundary (thank you @joshcoales for your assistance) Default behavior is to now re-encode audio tracks using the aac codec when using split-video (it can be overridden in both the command line and Python interface) Improved timestamp accuracy when using split-video command to further reduce instances of duplicated or off-by-one frame issues Fixed application crash when using the -l / --logfile argument","title":"Release Notes"},{"location":"changelog/#changelog_7","text":"[bugfix] Changed default audio codec from 'copy' to 'aac' when splitting scenes with ffmpeg to reduce frequency of frames from next scene showing up at the end of the current one when split using ffmpeg (see #93 , #159 , and PR #166 - thank you everyone for your assistance, especially joshcoales, amvscenes, jelias, and typoman). If this still occurs, please provide any information you can by filing a new issue on Github . [enhancement] video_splitter module now has completed documentation [bugfix] improve timestamp accuracy using the split-video command due to timecode formatting [bugfix] fix crash when supplying -l / --logfile argument (see #169 , thanks @typoman)","title":"Changelog"},{"location":"changelog/#known-issues_4","text":"Seeking through long videos is inefficient, causing the time and save-images command to take a long time to run. This will be resolved in the next release (see #98 ) The save-images command causes PySceneDetect to crash under Python 2.7 (see #174 ) Using detect-threshold with a statsfile causes PySceneDetect to crash (see #122 ) Variable framerate videos are not supported properly currently (#168), a warning may be added in the next release to indicate when a VFR video is detected, until this can be properly resolved ( #168 ) Videos with multiple audio tracks may not work correctly, see this comment on #179 for a workaround using ffmpeg or mkvmerge","title":"Known Issues"},{"location":"changelog/#052-march-29-2020","text":"[enhancement] --min-duration now accepts a timecode in addition to frame number ( #128 , thanks @tonycpsu) [feature] Add --image-frame-margin option to save-images command to ignore a number of frames at the start/end of a scene ( #129 , thanks @tonycpsu) [bugfix] --min-scene-len option was not respected by first scene ( #105 , thanks @charlesvestal) [bugfix] Splitting videos with an analyzed duration only splits within analyzed area ( #106 , thanks @charlesvestal) [bugfix] Improper start timecode applied to the split-video command when using ffmpeg ( #93 , thanks @typoman) [bugfix] Added links and filename sanitation to html output ( #139 and #140 , thanks @wjs018) [bugfix] UnboundLocalError in detect_scenes when frame_skip is larger than 0 ( #126 , thanks @twostarxx)","title":"0.5.2 (March 29, 2020)"},{"location":"changelog/#0511-august-3-2019","text":"minor re-release of v0.5.1 which updates the setup.py file to return OpenCV as an optional dependency to install from pip now with all dependencies: pip install scenedetect[opencv,progress_bar] to install only PySceneDetect: pip install scenedetect (separate OpenCV installation required) the release notes of v0.5.1 have been modified to include the prior command no change to PySceneDetect program version [feature] add get_duration method to VideoManager ( #109 , thanks @arianaa30)","title":"0.5.1.1 (August 3, 2019)"},{"location":"changelog/#051-july-20-2019","text":"[feature] Add new export-html command to the CLI (thanks @wjs018 ) [bugfix] VideoManager read function failed on multiple videos (thanks @ivan23kor ) [bugfix] Fix crash when no scenes are detected ( #79 , thanks @raj6996) [bugfix] Fixed OpenCV not getting installed due to missing dependency ( #73 ) [enhance] When no scenes are detected, the whole video is now returned instead of nothing (thanks @piercus ) Removed Windows installer due to binary packages now being available, and to streamline the release process (see #102 for more information). When you type pip install scenedetect[opencv,progress_bar] , all dependencies will be installed.","title":"0.5.1 (July 20, 2019)"},{"location":"changelog/#05-august-31-2018","text":"major release, includes stable Python API with examples and updated documentation numerous changes to command-line interface with addition of sub-commands (see the new manual for updated usage information) [feature] videos are now split using ffmpeg by default, resulting in frame-perfect cuts (can still use mkvmerge by specifying the -c / --copy argument to the split-video command) [enhance] image filename numbers are now consistent with those of split video scenes (PR #39, thanks @e271828- ) [enhance] 5-10% improvement in processing performance due to reduced memory copy operations (PR #40, thanks @elcombato ) [enhance] updated exception handling to raise proper standard exceptions (PR #37, thanks @talkain ) several fixes to the documentation, including improper dates and outdated CLI arguments (PR #26 and #, thanks @elcombato , and @colelawrence ) numerous other PRs and issues/bug reports that have been fixed - there are too many to list individually here, so I want to extend a big thank you to everyone who contributed to making this release better [enhance] add Sphinx-generated API documentation (available at: http://manual.scenedetect.com) [project] move from BSD 2-clause to 3-clause license","title":"0.5 (August 31, 2018)"},{"location":"changelog/#pyscenedetect-04","text":"","title":"PySceneDetect 0.4"},{"location":"changelog/#04-january-14-2017","text":"major release, includes integrated scene splitting via mkvmerge, changes meaning of -o / --output option [feature] specifying -o OUTPUT_FILE.mkv will now automatically split the input video, generating a new video clip for each detected scene in sequence, starting with OUTPUT_FILE-001.mkv [enhance] CSV file output is now specified with the -co / --csv-output option ( note, used to be -o in versions of PySceneDetect < 0.4 )","title":"0.4 (January 14, 2017)"},{"location":"changelog/#pyscenedetect-03-beta","text":"","title":"PySceneDetect 0.3-beta"},{"location":"changelog/#036-january-12-2017","text":"[enhance] performance improvement when using --frameskip option (thanks @marcelluzs ) [internal] moved application state and shared objects to a consistent interface (the SceneManager object) to greatly reduce the number of required arguments for certain API functions [enhance] added installer for Windows builds (64-bit only currently)","title":"0.3.6 (January 12, 2017)"},{"location":"changelog/#035-august-2-2016","text":"[enhance] initial release of portable build for Windows (64-bit only), including all dependencies [bugfix] fix unrelated exception thrown when video could not be loaded (thanks @marcelluzs ) [internal] fix variable name typo in API documentation","title":"0.3.5 (August 2, 2016)"},{"location":"changelog/#034-february-8-2016","text":"[enhance] add scene length, in seconds, to output file ( -o ) for easier integration with ffmpeg / libav [enhance] improved performance of content detection mode by caching intermediate HSV frames in memory (approx. 2x faster) [enhance] show timecode values in terminal when using extended output ( -l ) [feature] add fade bias option ( -fb / --fade-bias ) to command line (threshold mode only)","title":"0.3.4 (February 8, 2016)"},{"location":"changelog/#033-january-27-2016","text":"[bugfix] output scenes are now correctly written to specified output file when using -o flag (fixes #11) [bugfix] fix indexing exception when using multiple scene detectors and outputting statistics [internal] distribute package on PyPI, version move from beta to stable [internal] add function to convert frame number to formatted timecode [internal] move file and statistic output to Python csv module","title":"0.3.3 (January 27, 2016)"},{"location":"changelog/#032-beta-january-26-2016","text":"[feature] added -si / --save-images flag to enable saving the first and last frames of each detected scene as an image, saved in the current working directory with the original video filename as the output prefix [feature] added command line options for setting start and end times for processing ( -st and -et ) [feature] added command line option to specify maximum duration to process ( -dt , overrides -et )","title":"0.3.2-beta (January 26, 2016)"},{"location":"changelog/#031-beta-january-23-2016","text":"[feature] added downscaling/subsampling option ( -df / --downscale-factor ) to improve performance on higher resolution videos [feature] added frameskip option ( -fs / --frame-skip ) to improve performance on high framerate videos, at expense of frame accuracy and possible inaccurate scene cut prediction [enhance] added setup.py to allow for one-line installation (just run python setup.py install after downloading and extracting PySceneDetect) [internal] additional API functions to remove requirement on passing OpenCV video objects, and allow just a file path instead","title":"0.3.1-beta (January 23, 2016)"},{"location":"changelog/#03-beta-january-8-2016","text":"major release, includes improved detection algorithms and complete internal code refactor [feature] content-aware scene detection using HSV-colourspace based algorithm (use -d content ) [enhance] added CLI flags to allow user changes to more algorithm properties [internal] re-implemented threshold-based scene detection algorithm under new interface [internal] major code refactor including standard detection algorithm interface and API [internal] remove statistics mode until update to new detection mode interface","title":"0.3-beta (January 8, 2016)"},{"location":"changelog/#pyscenedetect-02-alpha","text":"","title":"PySceneDetect 0.2-alpha"},{"location":"changelog/#024-alpha-december-22-2015","text":"[bugfix] updated OpenCV compatibility with self-reported version on some Linux distributions","title":"0.2.4-alpha (December 22, 2015)"},{"location":"changelog/#023-alpha-august-7-2015","text":"[bugfix] updated PySceneDetect to work with latest OpenCV module (ver > 3.0) [bugfix] added compatibility/legacy code for older versions of OpenCV [feature] statsfile generation includes expanded frame metrics","title":"0.2.3-alpha (August 7, 2015)"},{"location":"changelog/#022-alpha-november-25-2014","text":"[feature] added statistics mode for generating frame-by-frame analysis (-s / --statsfile flag) [bugfix] fixed improper timecode conversion","title":"0.2.2-alpha (November 25, 2014)"},{"location":"changelog/#021-alpha-november-16-2014","text":"[enhance] proper timecode format (HH:MM:SS.nnnnn) [enhance] one-line of CSV timecodes added for easy splitting with external tool","title":"0.2.1-alpha (November 16, 2014)"},{"location":"changelog/#02-alpha-june-9-2014","text":"[enhance] now provides discrete scene list (in addition to fades) [feature] ability to output to file (-o / --output flag)","title":"0.2-alpha (June 9, 2014)"},{"location":"changelog/#pyscenedetect-01-alpha","text":"","title":"PySceneDetect 0.1-alpha"},{"location":"changelog/#01-alpha-june-8-2014","text":"first public release [feature] threshold-based fade in/out detection","title":"0.1-alpha (June 8, 2014)"},{"location":"changelog/#development","text":"","title":"Development"},{"location":"changelog/#pyscenedetect-066-in-development","text":"[bugfix] Fix crash when using split-video with -m / --mkvmerge option #473 [bugfix] Fix incorrect default filename template for split-video command with -m / --mkvmerge option [bugfix] Fix inconsistent filenames when using split_video_mkvmerge() function in scenedetect.video_splitter module","title":"PySceneDetect 0.6.6 (In Development)"},{"location":"cli/","text":"PySceneDetect CLI See the documentation for a complete reference to the scenedetect command with more examples. Quickstart Split input video on each fast cut using ffmpeg : scenedetect -i video.mp4 split-video Save some frames from each cut: scenedetect -i video.mp4 save-images Skip the first 10 seconds of the input video: scenedetect -i video.mp4 time -s 10s Example As a concrete example to become familiar with PySceneDetect, let's use the following short clip from the James Bond movie, GoldenEye (Copyright \u00a9 1995 MGM): https://www.youtube.com/watch?v=OMgIPnCnlbQ You can download the clip from here (right-click and save the video in your working directory as goldeneye.mp4 ). Let's split this scene into clips on each fast cut. This means we need to use content-aware detecton mode ( detect-content ) or adaptive mode ( detect-adaptive ). If the video instead contains fade-in/fade-out transitions you want to find, you can use detect-threshold instead. If no detector is specified, detect-adaptive will be used by default. Let's first save a scene list in CSV format and generate some images of each scene to check the output: scenedetect --input goldeneye.mp4 detect-adaptive list-scenes save-images Running the above command, in the working directory, you should see a file goldeneye-Scenes.csv , as well as individual frames for the start/middle/end of each scene starting with goldeneye-Scene-001-01.jpg . The results should appear as follows: Scene # Start Time Preview 1 00:00:00.000 2 00:00:03.754 3 00:00:08.759 4 00:00:10.802 5 00:00:15.599 6 00:00:27.110 7 00:00:34.117 8 00:00:36.536 ... ... ... 18 00:01:06.316 19 00:01:10.779 20 00:01:18.036 21 00:01:19.913 22 00:01:21.999 Splitting Video into Clips The split-video command can be used to automatically split the input video using ffmpeg or mkvmerge . For example: scenedetect -i goldeneye.mp4 split-video Type scenedetect split-video --help for a full list of options which can be specified for video splitting, including high quality mode ( -hq/--high-quality ) or copy mode ( -c/--copy ). You can also specify -h / --high-quality to produces near lossless results, or -p / --preset and -crf / --rate-factor (call scenedetect help split-video for details). If either -c / --copy or -m / --mkvmerge is specified, codec copying mode is used, at the expense of frame accurate cuts. Optionally, you can also specify the x264 -p / --preset and -crf / --rate-factor (see scenedetect split-video --help for details). Detection Methods PySceneDetect can look for fades in/out using detect-threshold (comparing each frame to a set black level) or find fast cuts using detect-content (compares each frame looking for changes in content). There also is detect-adaptive , which uses the same scoring as detect-content , but compares the ratio of each frame score to its neighbors. Each mode has slightly different parameters, and is described in detail below. Most detector parameters can also be set with a config file . In general, use detect-threshold mode if you want to detect scene boundaries using fades/cuts in/out to black. If the video uses a lot of fast cuts between content, and has no well-defined scene boundaries, you should use the detect-adaptive or detect-content modes. Once you know what detection mode to use, you can try the parameters recommended below, or generate a statistics file (using the -s / --stats flag) in order to determine the correct parameters - specifically, the proper threshold value. Content-Aware Detection Unlike threshold mode, content-aware mode looks at the difference between each pair of adjacent frames, triggering a scene break when this difference exceeds the threshold value. The optimal threshold can be determined by generating a stats file ( -s ), opening it with a spreadsheet editor (e.g. Excel), and examining the content_val column ( example ). This value should be very small between similar frames, and grow large when a big change in content is noticed (look at the values near frame numbers/times where you know a scene change occurs). The threshold value should be set so that most scenes fall below the threshold value, and scenes where changes occur should exceed the threshold value (thus triggering a scene change). Threshold Detection Threshold-based mode is what most traditional scene detection programs use, which looks at the average intensity of the current frame, triggering a scene break when the intensity falls below the threshold (or crosses back upwards). The default threshold when using the detect-threshold is 12 (e.g. detect-threshold is the same as detect-threshold --threshold 12 when the -t / --threshold option is not supplied), which is a good value to try when detecting fade outs to black on most videos. scenedetect -i my_video.mp4 -s my_video.stats.mp4 detect-threshold scenedetect -i my_video.mp4 -s my_video.stats.mp4 detect-threshold -t 20 Using values for threshold less than 8 may cause problems with some videos, especially those encoded at lower bitrates or with limited dynamic range. The optimal threshold can be determined by generating a statsfile ( -s ), opening it with a spreadsheet editor (e.g. Excel), and examining the delta_rgb column. These values represent the average intensity of the pixels for that particular frame (taken by averaging the R, G, and B values over the whole frame). The threshold value should be set so that the average intensity of most frames in content scenes lie above the threshold value, and scenes where scene changes/breaks occur should fall under the threshold value (thus triggering a scene change). Adaptive Detection The detect-adaptive mode compares each frame's score as calculated by detect-content with its neighbors. This score is what forms the adaptive_ratio metric in the statsfile. You can also configure the amount of neighboring frames via the frame-window option, as well as the minimum change in content_val score using min-content-val . Detection Parameters Detectors take a variety of parameters, which can be configured via command-line or by using a config file . If the default parameters do not produce correct results, you can generate a stats file using the -s / --stats option. For example, with detect-content , if the default threshold of 27 does not produce correct results, we can determine the proper threshold by first generating a stats file: scenedetect --input goldeneye.mp4 --stats goldeneye.stats.csv detect-adaptive We can then plot the values of the content_val column: The peaks in values correspond to the scene breaks in the input video. In some cases the threshold may need to be raised or lowered accordingly. Saving Image Previews of Detected Scenes PySceneDetect can automatically save the beginning and ending frame of each detected scene by using the save-images command. If present, the first and last frames of each scene will be saved in the current working directory, using the filename of the input video. Files marked 00 represent the starting frame of the scene, and those marked 01 represent the last frame (e.g. testvideo.mp4.Scene-4-01.jpg ). By default, two images are generated. Coming soon: If more are specified via the -n flag, they will start from 00 (the first frame) and be evenly spaced throughout the scene until the last frame, which will be numbered N-1 . Improving Processing Speed/Performance The following arguments are global program options, and need to be applied before any commands (e.g. detect-content , list-scenes ). They can be used to achieve performance gains for some source material with a variable loss of accuracy. Assuming the input video is of a high enough resolution, a significant performance gain can be achieved by sub-sampling (down-scaling) the input image by a specific integer factor (2x, 3x, 4x, 5x...). This is applied automatically to some degree based on the input video size, but can be overridden manually with the -d / --downscale option. This factor represents how many pixels are \"skipped\" in both the x- and y- directions, effectively down-scaling the image (using nearest-neighbor sampling) by the factor specified (the new resolution being W/factor x H/factor if the old resolution is W x H ). Another method that can be used to gain a performance boost is frame skipping. This method, however, severely reduces frame-accurate scene cuts, so it should only be used with high FPS material (ideally > 60 FPS), at low values (try not to exceed a value of 1 or 2 if using -fs / --frame-skip ), in cases where this is acceptable. Using the frame skip option also disallows the use of a stats file, which offsets the speed gain if the same video needs to be processed multiple times (e.g. to determine the optimal threshold). The option still remains, however, for the set of cases where it is still required. For example, if we skip every other frame (e.g. using --frame-skip 1 ), the processing speed should roughly double. If set too large, enough frames may be skipped each time that the threshold is met during every iteration, continually triggering scene changes. This is because frame skipping essentially raises the threshold between frames in the same scene (making them more likely to appear as cuts ) while not affecting the threshold between frames of different scenes. This makes the two harder to distinguish, and can cause additional false scene cuts to be detected. While this can be compensated for by raising the threshold value, this increases the probability of missing a real/true scene cut - thus, the use of the -fs / --frame-skip option is discouraged. Seeking, Duration, and Setting Start / Stop Times Specifying the time command allows control over what portion of the video PySceneDetect processes. The time command accepts three options: start time ( -s / -start ), end time ( -e / -end ), and duration ( -d / --duration ). Specifying both end time and duration is redundant, and in this case, duration overrides end time. Timecodes can be given in seconds ( 100.0 ), frames (no decimal place, 100 ), or timecode as HH:MM:SS[.nnn] ( 12:34:56.789 ). For example, let's say we have a video shot at 30 FPS, and want to analyze only the segment from the 5 to the 6.5 minute mark in the video (we want to analyze the 90 seconds [2700 frames] between 00:05:00 and 00:06:30). The following commands are all thus equivalent in this regard (assuming we are using the content detector): scenedetect -i my_video.mp4 time --start 00:05:00 --end 00:06:30 scenedetect -i my_video.mp4 time --start 300s --end 390s scenedetect -i my_video.mp4 time --start 300s --duration 90s scenedetect -i my_video.mp4 time --start 300s --duration 2700 This demonstrates the different timecode formats, interchanging end time with duration and vice-versa, and precedence of setting duration over end time. Config File A configuration file path can be specified using the -c / --config argument. PySceneDetect also looks for a config file named scenedetect.cfg in one of the following locations: Windows: C:/Users/%USERNAME%/AppData/Local/PySceneDetect/scenedetect.cfg Linux: ~/.config/PySceneDetect/scenedetect.cfg $XDG_CONFIG_HOME/scenedetect.cfg Mac: ~/Library/Preferences/PySceneDetect/scenedetect.cfg Run scenedetect --help to see the exact path on your system which will be used (it will be listed under the help text for the -c/--config option). You can click here to download a scenedetect.cfg config file to use as a template. Note that lines starting with a # are comments and will be ignored. The scenedetect.cfg template file is also available in the folder where PySceneDetect is installed. Specifying a config file path using -c/--config overrides the user config file. Specifying values on the command line will override those values in the config file. The syntax of a configuration file is: [command] option_a = value #comment option_b = 1 Example [global] default-detector = detect-content min-scene-len = 0.8s [detect-content] threshold = 32 weights = 1.0 0.5 1.0 0.2 [split-video] preset = slow rate-factor = 17 # Don't need to use quotes even if filename contains spaces filename = $VIDEO_NAME-Clip-$SCENE_NUMBER [save-images] format = jpeg quality = 80 num-images = 3 See the scenedetect.cfg file in the location you installed PySceneDetect or download it from Github for a complete listing of all configuration options. Video Splitting Requirements PySceneDetect can use either ffmpeg or mkvmerge to split videos automatically. By default, when specifying the split-video command, ffmpeg will be used to split the video. If the -c / --copy option is also set (e.g. split-video --copy ), mkvmerge will be used to split the video instead. FFmpeg You can download ffmpeg from: https://ffmpeg.org/download.html Note that Linux users should use a package manager (e.g. sudo apt-get install ffmpeg ). Windows users may require additional steps in order for PySceneDetect to detect ffmpeg - see the section Manually Enabling split-video Support below for details. mkvmerge You can download and install mkvmerge as part of the mkvtoolnix package from: https://mkvtoolnix.download/downloads.html Note that Windows users should use the installer/setup, and Linux users should use their system package manager, otherwise PySceneDetect may not be able to find mkvmerge . If this is the case, see the section below to enable support for the split-video --copy command manually. Enabling split-video Support If PySceneDetect cannot find the respective tool installed on your system, you have three options: Place the tool in the same location that PySceneDetect is installed (e.g. copy and paste mkvmerge.exe into the same place scenedetect.exe is located). This is the easiest solution for most users. Add the directory where you installed ffmpeg/mkvmerge to your system's PATH environment variable, ensuring that you can use the ffmpeg/mkvmerge command from any terminal/command prompt. This is the best solution for advanced users. Place the tool in a location already in your system's PATH variable (e.g. C:/Windows). This is not recommended, but may be the only solution on systems without administrative rights.","title":"Command-Line"},{"location":"cli/#pyscenedetect-cli","text":"See the documentation for a complete reference to the scenedetect command with more examples.","title":"PySceneDetect CLI"},{"location":"cli/#quickstart","text":"Split input video on each fast cut using ffmpeg : scenedetect -i video.mp4 split-video Save some frames from each cut: scenedetect -i video.mp4 save-images Skip the first 10 seconds of the input video: scenedetect -i video.mp4 time -s 10s","title":"Quickstart"},{"location":"cli/#example","text":"As a concrete example to become familiar with PySceneDetect, let's use the following short clip from the James Bond movie, GoldenEye (Copyright \u00a9 1995 MGM): https://www.youtube.com/watch?v=OMgIPnCnlbQ You can download the clip from here (right-click and save the video in your working directory as goldeneye.mp4 ). Let's split this scene into clips on each fast cut. This means we need to use content-aware detecton mode ( detect-content ) or adaptive mode ( detect-adaptive ). If the video instead contains fade-in/fade-out transitions you want to find, you can use detect-threshold instead. If no detector is specified, detect-adaptive will be used by default. Let's first save a scene list in CSV format and generate some images of each scene to check the output: scenedetect --input goldeneye.mp4 detect-adaptive list-scenes save-images Running the above command, in the working directory, you should see a file goldeneye-Scenes.csv , as well as individual frames for the start/middle/end of each scene starting with goldeneye-Scene-001-01.jpg . The results should appear as follows: Scene # Start Time Preview 1 00:00:00.000 2 00:00:03.754 3 00:00:08.759 4 00:00:10.802 5 00:00:15.599 6 00:00:27.110 7 00:00:34.117 8 00:00:36.536 ... ... ... 18 00:01:06.316 19 00:01:10.779 20 00:01:18.036 21 00:01:19.913 22 00:01:21.999","title":"Example"},{"location":"cli/#splitting-video-into-clips","text":"The split-video command can be used to automatically split the input video using ffmpeg or mkvmerge . For example: scenedetect -i goldeneye.mp4 split-video Type scenedetect split-video --help for a full list of options which can be specified for video splitting, including high quality mode ( -hq/--high-quality ) or copy mode ( -c/--copy ). You can also specify -h / --high-quality to produces near lossless results, or -p / --preset and -crf / --rate-factor (call scenedetect help split-video for details). If either -c / --copy or -m / --mkvmerge is specified, codec copying mode is used, at the expense of frame accurate cuts. Optionally, you can also specify the x264 -p / --preset and -crf / --rate-factor (see scenedetect split-video --help for details).","title":"Splitting Video into Clips"},{"location":"cli/#detection-methods","text":"PySceneDetect can look for fades in/out using detect-threshold (comparing each frame to a set black level) or find fast cuts using detect-content (compares each frame looking for changes in content). There also is detect-adaptive , which uses the same scoring as detect-content , but compares the ratio of each frame score to its neighbors. Each mode has slightly different parameters, and is described in detail below. Most detector parameters can also be set with a config file . In general, use detect-threshold mode if you want to detect scene boundaries using fades/cuts in/out to black. If the video uses a lot of fast cuts between content, and has no well-defined scene boundaries, you should use the detect-adaptive or detect-content modes. Once you know what detection mode to use, you can try the parameters recommended below, or generate a statistics file (using the -s / --stats flag) in order to determine the correct parameters - specifically, the proper threshold value.","title":"Detection Methods"},{"location":"cli/#content-aware-detection","text":"Unlike threshold mode, content-aware mode looks at the difference between each pair of adjacent frames, triggering a scene break when this difference exceeds the threshold value. The optimal threshold can be determined by generating a stats file ( -s ), opening it with a spreadsheet editor (e.g. Excel), and examining the content_val column ( example ). This value should be very small between similar frames, and grow large when a big change in content is noticed (look at the values near frame numbers/times where you know a scene change occurs). The threshold value should be set so that most scenes fall below the threshold value, and scenes where changes occur should exceed the threshold value (thus triggering a scene change).","title":"Content-Aware Detection"},{"location":"cli/#threshold-detection","text":"Threshold-based mode is what most traditional scene detection programs use, which looks at the average intensity of the current frame, triggering a scene break when the intensity falls below the threshold (or crosses back upwards). The default threshold when using the detect-threshold is 12 (e.g. detect-threshold is the same as detect-threshold --threshold 12 when the -t / --threshold option is not supplied), which is a good value to try when detecting fade outs to black on most videos. scenedetect -i my_video.mp4 -s my_video.stats.mp4 detect-threshold scenedetect -i my_video.mp4 -s my_video.stats.mp4 detect-threshold -t 20 Using values for threshold less than 8 may cause problems with some videos, especially those encoded at lower bitrates or with limited dynamic range. The optimal threshold can be determined by generating a statsfile ( -s ), opening it with a spreadsheet editor (e.g. Excel), and examining the delta_rgb column. These values represent the average intensity of the pixels for that particular frame (taken by averaging the R, G, and B values over the whole frame). The threshold value should be set so that the average intensity of most frames in content scenes lie above the threshold value, and scenes where scene changes/breaks occur should fall under the threshold value (thus triggering a scene change).","title":"Threshold Detection"},{"location":"cli/#adaptive-detection","text":"The detect-adaptive mode compares each frame's score as calculated by detect-content with its neighbors. This score is what forms the adaptive_ratio metric in the statsfile. You can also configure the amount of neighboring frames via the frame-window option, as well as the minimum change in content_val score using min-content-val .","title":"Adaptive Detection"},{"location":"cli/#detection-parameters","text":"Detectors take a variety of parameters, which can be configured via command-line or by using a config file . If the default parameters do not produce correct results, you can generate a stats file using the -s / --stats option. For example, with detect-content , if the default threshold of 27 does not produce correct results, we can determine the proper threshold by first generating a stats file: scenedetect --input goldeneye.mp4 --stats goldeneye.stats.csv detect-adaptive We can then plot the values of the content_val column: The peaks in values correspond to the scene breaks in the input video. In some cases the threshold may need to be raised or lowered accordingly.","title":"Detection Parameters"},{"location":"cli/#saving-image-previews-of-detected-scenes","text":"PySceneDetect can automatically save the beginning and ending frame of each detected scene by using the save-images command. If present, the first and last frames of each scene will be saved in the current working directory, using the filename of the input video. Files marked 00 represent the starting frame of the scene, and those marked 01 represent the last frame (e.g. testvideo.mp4.Scene-4-01.jpg ). By default, two images are generated. Coming soon: If more are specified via the -n flag, they will start from 00 (the first frame) and be evenly spaced throughout the scene until the last frame, which will be numbered N-1 .","title":"Saving Image Previews of Detected Scenes"},{"location":"cli/#improving-processing-speedperformance","text":"The following arguments are global program options, and need to be applied before any commands (e.g. detect-content , list-scenes ). They can be used to achieve performance gains for some source material with a variable loss of accuracy. Assuming the input video is of a high enough resolution, a significant performance gain can be achieved by sub-sampling (down-scaling) the input image by a specific integer factor (2x, 3x, 4x, 5x...). This is applied automatically to some degree based on the input video size, but can be overridden manually with the -d / --downscale option. This factor represents how many pixels are \"skipped\" in both the x- and y- directions, effectively down-scaling the image (using nearest-neighbor sampling) by the factor specified (the new resolution being W/factor x H/factor if the old resolution is W x H ). Another method that can be used to gain a performance boost is frame skipping. This method, however, severely reduces frame-accurate scene cuts, so it should only be used with high FPS material (ideally > 60 FPS), at low values (try not to exceed a value of 1 or 2 if using -fs / --frame-skip ), in cases where this is acceptable. Using the frame skip option also disallows the use of a stats file, which offsets the speed gain if the same video needs to be processed multiple times (e.g. to determine the optimal threshold). The option still remains, however, for the set of cases where it is still required. For example, if we skip every other frame (e.g. using --frame-skip 1 ), the processing speed should roughly double. If set too large, enough frames may be skipped each time that the threshold is met during every iteration, continually triggering scene changes. This is because frame skipping essentially raises the threshold between frames in the same scene (making them more likely to appear as cuts ) while not affecting the threshold between frames of different scenes. This makes the two harder to distinguish, and can cause additional false scene cuts to be detected. While this can be compensated for by raising the threshold value, this increases the probability of missing a real/true scene cut - thus, the use of the -fs / --frame-skip option is discouraged.","title":"Improving Processing Speed/Performance"},{"location":"cli/#seeking-duration-and-setting-start-stop-times","text":"Specifying the time command allows control over what portion of the video PySceneDetect processes. The time command accepts three options: start time ( -s / -start ), end time ( -e / -end ), and duration ( -d / --duration ). Specifying both end time and duration is redundant, and in this case, duration overrides end time. Timecodes can be given in seconds ( 100.0 ), frames (no decimal place, 100 ), or timecode as HH:MM:SS[.nnn] ( 12:34:56.789 ). For example, let's say we have a video shot at 30 FPS, and want to analyze only the segment from the 5 to the 6.5 minute mark in the video (we want to analyze the 90 seconds [2700 frames] between 00:05:00 and 00:06:30). The following commands are all thus equivalent in this regard (assuming we are using the content detector): scenedetect -i my_video.mp4 time --start 00:05:00 --end 00:06:30 scenedetect -i my_video.mp4 time --start 300s --end 390s scenedetect -i my_video.mp4 time --start 300s --duration 90s scenedetect -i my_video.mp4 time --start 300s --duration 2700 This demonstrates the different timecode formats, interchanging end time with duration and vice-versa, and precedence of setting duration over end time.","title":"Seeking, Duration, and Setting Start / Stop Times"},{"location":"cli/#config-file","text":"A configuration file path can be specified using the -c / --config argument. PySceneDetect also looks for a config file named scenedetect.cfg in one of the following locations: Windows: C:/Users/%USERNAME%/AppData/Local/PySceneDetect/scenedetect.cfg Linux: ~/.config/PySceneDetect/scenedetect.cfg $XDG_CONFIG_HOME/scenedetect.cfg Mac: ~/Library/Preferences/PySceneDetect/scenedetect.cfg Run scenedetect --help to see the exact path on your system which will be used (it will be listed under the help text for the -c/--config option). You can click here to download a scenedetect.cfg config file to use as a template. Note that lines starting with a # are comments and will be ignored. The scenedetect.cfg template file is also available in the folder where PySceneDetect is installed. Specifying a config file path using -c/--config overrides the user config file. Specifying values on the command line will override those values in the config file. The syntax of a configuration file is: [command] option_a = value #comment option_b = 1","title":"Config File"},{"location":"cli/#example_1","text":"[global] default-detector = detect-content min-scene-len = 0.8s [detect-content] threshold = 32 weights = 1.0 0.5 1.0 0.2 [split-video] preset = slow rate-factor = 17 # Don't need to use quotes even if filename contains spaces filename = $VIDEO_NAME-Clip-$SCENE_NUMBER [save-images] format = jpeg quality = 80 num-images = 3 See the scenedetect.cfg file in the location you installed PySceneDetect or download it from Github for a complete listing of all configuration options.","title":"Example"},{"location":"cli/#video-splitting-requirements","text":"PySceneDetect can use either ffmpeg or mkvmerge to split videos automatically. By default, when specifying the split-video command, ffmpeg will be used to split the video. If the -c / --copy option is also set (e.g. split-video --copy ), mkvmerge will be used to split the video instead.","title":"&nbsp; Video Splitting Requirements"},{"location":"cli/#ffmpeg","text":"You can download ffmpeg from: https://ffmpeg.org/download.html Note that Linux users should use a package manager (e.g. sudo apt-get install ffmpeg ). Windows users may require additional steps in order for PySceneDetect to detect ffmpeg - see the section Manually Enabling split-video Support below for details.","title":"FFmpeg"},{"location":"cli/#mkvmerge","text":"You can download and install mkvmerge as part of the mkvtoolnix package from: https://mkvtoolnix.download/downloads.html Note that Windows users should use the installer/setup, and Linux users should use their system package manager, otherwise PySceneDetect may not be able to find mkvmerge . If this is the case, see the section below to enable support for the split-video --copy command manually.","title":"mkvmerge"},{"location":"cli/#enabling-split-video-support","text":"If PySceneDetect cannot find the respective tool installed on your system, you have three options: Place the tool in the same location that PySceneDetect is installed (e.g. copy and paste mkvmerge.exe into the same place scenedetect.exe is located). This is the easiest solution for most users. Add the directory where you installed ffmpeg/mkvmerge to your system's PATH environment variable, ensuring that you can use the ffmpeg/mkvmerge command from any terminal/command prompt. This is the best solution for advanced users. Place the tool in a location already in your system's PATH variable (e.g. C:/Windows). This is not recommended, but may be the only solution on systems without administrative rights.","title":"Enabling split-video Support"},{"location":"contributing/","text":"Bug Reports Bugs, issues, features, and improvements to PySceneDetect are handled through the issue tracker on Github . If you run into any bugs using PySceneDetect, please create a new issue . Try to find an existing issue before creating a new one, as there may be a workaround posted there. Additional information is also helpful for existing reports. Contributing to Development Development of PySceneDetect happens on github.com/Breakthrough/PySceneDetect . Pull requests are accepted and encouraged. Where possible, PRs should be submitted with a dedicated entry in the issue tracker . Issues and features are typically grouped into version milestones. The following checklist covers the basics of pre-submission requirements: Code passes all unit tests (run pytest ) Code passes static analysis and formatting checks ( ruff check and ruff format ) Follows the Google Python Style Guide Note that PySceneDetect is released under the BSD 3-Clause license, and submitted code should comply with this license (see License & Copyright Information for details). Features That Need Help The following is a \"wishlist\" of features which PySceneDetect eventually should have, but does not currently due to lack of resources. Anyone who is able to contribute in any capacity to these items is encouraged to do so by starting a dialogue by opening a new issue on Github as per above. Flash Suppression Some detection methods struggle with bright flashes and fast camera movement. The detection pipeline has some filters in place to deal with these cases, but there are still drawbacks. We are actively seeking methods which can improve both performance and accuracy in these cases. Automatic Thresholding The detect-content command requires a manual threshold to be set currently. Methods to use peak detection to dynamically determine when scene cuts occur would allow for the program to work with a much wider amount of material without requiring manual tuning, but would require statistical analysis. Ideally, this would be something like -threshold=auto as a default. Dissolve Detection Depending on the length of the dissolve and parameters being used, detection accuracy for these types of cuts can vary widely. A method to improve accuracy with minimal performance loss is an open problem. Advanced Strategies Research into detection methods and performance are ongoing. All contributions in this regard are most welcome. GUI A graphical user interface will be crucial for making PySceneDetect approchable by a wider audience. There have been several suggested designs, but nothing concrete has been developed yet. Any proposed solution for the GUI should work across Windows, Linux, and OSX. Localization PySceneDetect currently is not localized for other languages. Anyone who can help improve how localization can be approached for development material is encouraged to contribute in any way possible. Whether it is the GUI program, the command line interface, or documentation, localization will allow PySceneDetect to be used by much more users in their native languages.","title":"Bugs & Contributing"},{"location":"contributing/#bug-reports","text":"Bugs, issues, features, and improvements to PySceneDetect are handled through the issue tracker on Github . If you run into any bugs using PySceneDetect, please create a new issue . Try to find an existing issue before creating a new one, as there may be a workaround posted there. Additional information is also helpful for existing reports.","title":"&nbsp; Bug Reports"},{"location":"contributing/#contributing-to-development","text":"Development of PySceneDetect happens on github.com/Breakthrough/PySceneDetect . Pull requests are accepted and encouraged. Where possible, PRs should be submitted with a dedicated entry in the issue tracker . Issues and features are typically grouped into version milestones. The following checklist covers the basics of pre-submission requirements: Code passes all unit tests (run pytest ) Code passes static analysis and formatting checks ( ruff check and ruff format ) Follows the Google Python Style Guide Note that PySceneDetect is released under the BSD 3-Clause license, and submitted code should comply with this license (see License & Copyright Information for details).","title":"&nbsp; Contributing to Development"},{"location":"contributing/#features-that-need-help","text":"The following is a \"wishlist\" of features which PySceneDetect eventually should have, but does not currently due to lack of resources. Anyone who is able to contribute in any capacity to these items is encouraged to do so by starting a dialogue by opening a new issue on Github as per above.","title":"&nbsp; Features That Need Help"},{"location":"contributing/#flash-suppression","text":"Some detection methods struggle with bright flashes and fast camera movement. The detection pipeline has some filters in place to deal with these cases, but there are still drawbacks. We are actively seeking methods which can improve both performance and accuracy in these cases.","title":"Flash Suppression"},{"location":"contributing/#automatic-thresholding","text":"The detect-content command requires a manual threshold to be set currently. Methods to use peak detection to dynamically determine when scene cuts occur would allow for the program to work with a much wider amount of material without requiring manual tuning, but would require statistical analysis. Ideally, this would be something like -threshold=auto as a default.","title":"Automatic Thresholding"},{"location":"contributing/#dissolve-detection","text":"Depending on the length of the dissolve and parameters being used, detection accuracy for these types of cuts can vary widely. A method to improve accuracy with minimal performance loss is an open problem.","title":"Dissolve Detection"},{"location":"contributing/#advanced-strategies","text":"Research into detection methods and performance are ongoing. All contributions in this regard are most welcome.","title":"Advanced Strategies"},{"location":"contributing/#gui","text":"A graphical user interface will be crucial for making PySceneDetect approchable by a wider audience. There have been several suggested designs, but nothing concrete has been developed yet. Any proposed solution for the GUI should work across Windows, Linux, and OSX.","title":"GUI"},{"location":"contributing/#localization","text":"PySceneDetect currently is not localized for other languages. Anyone who can help improve how localization can be approached for development material is encouraged to contribute in any way possible. Whether it is the GUI program, the command line interface, or documentation, localization will allow PySceneDetect to be used by much more users in their native languages.","title":"Localization"},{"location":"copyright/","text":"PySceneDetect License Agreement PySceneDetect License (BSD 3-Clause) < http://www.bcastell.com/projects/PySceneDetect > Copyright (C) 2014-2024, Brandon Castellano. All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. Ancillary Software Licenses This section contains links to the license agreements for all third-party software libraries used and distributed with PySceneDetect. You can find copies of all the relevant license agreements referenced below if you installed a copy of PySceneDetect by looking at the LICENSE files in the installation directory. click Copyright (C) 2017, Armin Ronacher. URL: http://click.pocoo.org/license/ NumPy Copyright (C) 2005-2016, NumPy Developers. URL: http://www.numpy.org/license.html OpenCV Copyright (C) 2017, Itseez. URL: http://opencv.org/license.html PyAV Copyright (C) 2017, Mike Boers and others URL: https://github.com/PyAV-Org/PyAV/blob/main/LICENSE.txt simpletable Copyright (C) 2014-2019, Matheus Vieira Portela and others URL: https://github.com/matheusportela/simpletable/blob/master/LICENSE tqdm Copyright (C) 2013-2018, Casper da Costa-Luis, Google Inc., and Noam Yorav-Raphael. URL: https://raw.githubusercontent.com/tqdm/tqdm/master/LICENCE FFmpeg and mkvmerge This software may also invoke mkvmerge or FFmpeg, if available. FFmpeg is a trademark of Fabrice Bellard. mkvmerge is Copyright (C) 2005-2016, Matroska. Certain distributions of PySceneDetect may include ffmpeg. See the thirdparty/LICENSE-FFMPEG file or visit [ https://ffmpeg.org ].","title":"License & Copyright"},{"location":"copyright/#pyscenedetect-license-agreement","text":"PySceneDetect License (BSD 3-Clause) < http://www.bcastell.com/projects/PySceneDetect > Copyright (C) 2014-2024, Brandon Castellano. All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.","title":"PySceneDetect License Agreement"},{"location":"copyright/#ancillary-software-licenses","text":"This section contains links to the license agreements for all third-party software libraries used and distributed with PySceneDetect. You can find copies of all the relevant license agreements referenced below if you installed a copy of PySceneDetect by looking at the LICENSE files in the installation directory.","title":"Ancillary Software Licenses"},{"location":"copyright/#click","text":"Copyright (C) 2017, Armin Ronacher. URL: http://click.pocoo.org/license/","title":"click"},{"location":"copyright/#numpy","text":"Copyright (C) 2005-2016, NumPy Developers. URL: http://www.numpy.org/license.html","title":"NumPy"},{"location":"copyright/#opencv","text":"Copyright (C) 2017, Itseez. URL: http://opencv.org/license.html","title":"OpenCV"},{"location":"copyright/#pyav","text":"Copyright (C) 2017, Mike Boers and others URL: https://github.com/PyAV-Org/PyAV/blob/main/LICENSE.txt","title":"PyAV"},{"location":"copyright/#simpletable","text":"Copyright (C) 2014-2019, Matheus Vieira Portela and others URL: https://github.com/matheusportela/simpletable/blob/master/LICENSE","title":"simpletable"},{"location":"copyright/#tqdm","text":"Copyright (C) 2013-2018, Casper da Costa-Luis, Google Inc., and Noam Yorav-Raphael. URL: https://raw.githubusercontent.com/tqdm/tqdm/master/LICENCE","title":"tqdm"},{"location":"copyright/#ffmpeg-and-mkvmerge","text":"This software may also invoke mkvmerge or FFmpeg, if available. FFmpeg is a trademark of Fabrice Bellard. mkvmerge is Copyright (C) 2005-2016, Matroska. Certain distributions of PySceneDetect may include ffmpeg. See the thirdparty/LICENSE-FFMPEG file or visit [ https://ffmpeg.org ].","title":"FFmpeg and mkvmerge"},{"location":"docs/","text":"Documentation Stable latest v0.6.5 v0.6.4 v0.6.3 v0.6.2 v0.6.1 In Development head","title":"Documentation"},{"location":"docs/#documentation","text":"","title":"Documentation"},{"location":"docs/#stable","text":"latest v0.6.5 v0.6.4 v0.6.3 v0.6.2 v0.6.1","title":"Stable"},{"location":"docs/#in-development","text":"head","title":"In Development"},{"location":"download/","text":"Download PySceneDetect is completely free software, and can be downloaded from the links below. See the license and copyright information page for details. If you have trouble running PySceneDetect, ensure that you have all the required dependencies listed in the Dependencies section below. PySceneDetect requires at least Python 3.7 or higher. Install via pip Including OpenCV (recommended): pip install --upgrade scenedetect[opencv] Including Headless OpenCV (servers): pip install --upgrade scenedetect[opencv-headless] PySceneDetect is available via pip as the scenedetect package . Windows Build (64-bit Only) Latest Release: v0.6.5 Release Date: November 24, 2024 Installer (recommended) Portable .zip Getting Started Post Installation After installation, you can call PySceneDetect from any terminal/command prompt by typing scenedetect (try running scenedetect --help , or scenedetect version ). If you encounter any runtime errors while running PySceneDetect, ensure that you have all the required dependencies listed in the System Requirements section above (you should be able to import numpy and import cv2 ). If you encounter any issues or want to make a feature request, feel free to report any bugs or share some feature requests/ideas on the issue tracker and help make PySceneDetect even better. Dependencies Python Packages PySceneDetect requires Python 3 and the following packages: OpenCV : pip install opencv-python Numpy : pip install numpy Click : pip install Click tqdm : pip install tqdm appdirs : pip install appdirs Optional packages: PyAV : pip install av Video Splitting Tools For video splitting support, you need to have one of the following tools available (included in Windows builds): ffmpeg , required to split video files ( split-video or split-video -c/--copy ) mkvmerge , part of mkvtoolnix, command-line tool, required to split video files in stream copy mode ( split-video -c/--copy only) The ffmpeg and/or mkvmerge command must be available system wide (e.g. in a directory in PATH , so it can be used from any terminal/console by typing the command), or alternatively, placed in the same directory where PySceneDetect is installed. On Windows this is usually C:\\PythonXY\\Scripts , where XY is your Python version. For more information, see the CLI documentation . Building OpenCV from Source If you have installed OpenCV using pip , you will need to uninstall it before installing a different version of OpenCV, or building and installing it from source. You can click here for a quick guide (OpenCV + Numpy on Windows & Linux) on installing OpenCV/Numpy on Windows (using pre-built binaries) and Linux (compiling from source) . If the Python module that comes with OpenCV on Windows is incompatible with your system architecture or Python version, see this page to obtain a pre-compiled (unofficial) module. To ensure you have all the requirements installed, open a python interpreter, and ensure you can run import numpy and import cv2 without any errors. Code Signing Policy This program uses free code signing provided by SignPath.io , and a free code signing certificate by the SignPath Foundation","title":"Download"},{"location":"download/#download","text":"PySceneDetect is completely free software, and can be downloaded from the links below. See the license and copyright information page for details. If you have trouble running PySceneDetect, ensure that you have all the required dependencies listed in the Dependencies section below. PySceneDetect requires at least Python 3.7 or higher.","title":"Download"},{"location":"download/#install-via-pip","text":"","title":"Install via pip &nbsp; &nbsp; &nbsp;"},{"location":"download/#windows-build-64-bit-only","text":"","title":"Windows Build (64-bit Only) &nbsp;"},{"location":"download/#post-installation","text":"After installation, you can call PySceneDetect from any terminal/command prompt by typing scenedetect (try running scenedetect --help , or scenedetect version ). If you encounter any runtime errors while running PySceneDetect, ensure that you have all the required dependencies listed in the System Requirements section above (you should be able to import numpy and import cv2 ). If you encounter any issues or want to make a feature request, feel free to report any bugs or share some feature requests/ideas on the issue tracker and help make PySceneDetect even better.","title":"Post Installation"},{"location":"download/#dependencies","text":"","title":"Dependencies"},{"location":"download/#python-packages","text":"PySceneDetect requires Python 3 and the following packages: OpenCV : pip install opencv-python Numpy : pip install numpy Click : pip install Click tqdm : pip install tqdm appdirs : pip install appdirs Optional packages: PyAV : pip install av","title":"Python Packages"},{"location":"download/#video-splitting-tools","text":"For video splitting support, you need to have one of the following tools available (included in Windows builds): ffmpeg , required to split video files ( split-video or split-video -c/--copy ) mkvmerge , part of mkvtoolnix, command-line tool, required to split video files in stream copy mode ( split-video -c/--copy only) The ffmpeg and/or mkvmerge command must be available system wide (e.g. in a directory in PATH , so it can be used from any terminal/console by typing the command), or alternatively, placed in the same directory where PySceneDetect is installed. On Windows this is usually C:\\PythonXY\\Scripts , where XY is your Python version. For more information, see the CLI documentation .","title":"Video Splitting Tools"},{"location":"download/#building-opencv-from-source","text":"If you have installed OpenCV using pip , you will need to uninstall it before installing a different version of OpenCV, or building and installing it from source. You can click here for a quick guide (OpenCV + Numpy on Windows & Linux) on installing OpenCV/Numpy on Windows (using pre-built binaries) and Linux (compiling from source) . If the Python module that comes with OpenCV on Windows is incompatible with your system architecture or Python version, see this page to obtain a pre-compiled (unofficial) module. To ensure you have all the requirements installed, open a python interpreter, and ensure you can run import numpy and import cv2 without any errors.","title":"Building OpenCV from Source"},{"location":"download/#code-signing-policy","text":"This program uses free code signing provided by SignPath.io , and a free code signing certificate by the SignPath Foundation","title":"Code Signing Policy"},{"location":"faq/","text":"Frequently Asked Questions How can I fix ImportError: No module named cv2 ? You need to install OpenCV for PySceneDetect to properly work. If you're using pip , you can install it as follows: pip install scenedetect[opencv] Note that you may need to use a different/older version depending on your Python version. You can also use the headless package if you're running a server: pip install scenedetect[opencv-headless] Unlike calling pip install opencv-python , the above commands will download and install the correct OpenCV version based on the Python version you are running. How can I enable video splitting support? Video splitting is performed by ffmpeg ( https://ffmpeg.org/download.html ) or mkvmerge (https://mkvtoolnix.download/downloads.html) depending on which command line arguments are used. Ensure the tool is available and somewhere in your system's PATH folder. How can I fix the error Cannot split video due to too many scenes ? This error occurs on Windows platforms specifically when the number of detected scenes is too large. This is because PySceneDetect internally invokes other commands, such as those used for the split-video command. You can get around this issue by simply invoking those tools manually, using a smaller sub-set of scenes (or splitting the scene list into multiple parts). You can obtain a comma-separated list of timecodes by using the list-scenes command. See Issue #164 for details, or if you have any further questions. How can I fix the error Failed to read any frames from video file ? Unfortunately, the underlying library used to perform video I/O was unable to open the file. Try using a different backend by installing PyAV ( pip install av ) and see if the problem persists. This can also happen due to videos having multiple audio tracks (as per #179 ). If the PyAV backend does not succeed in processing the video, as a workaround you can remove the audio track using either ffmpeg or mkvmerge : ffmpeg -i input.mp4 -c copy -an output.mp4 Or: mkvmerge -o output.mkv input.mp4","title":"FAQ"},{"location":"faq/#frequently-asked-questions","text":"","title":"&nbsp; Frequently Asked Questions"},{"location":"faq/#how-can-i-fix-importerror-no-module-named-cv2","text":"You need to install OpenCV for PySceneDetect to properly work. If you're using pip , you can install it as follows: pip install scenedetect[opencv] Note that you may need to use a different/older version depending on your Python version. You can also use the headless package if you're running a server: pip install scenedetect[opencv-headless] Unlike calling pip install opencv-python , the above commands will download and install the correct OpenCV version based on the Python version you are running.","title":"How can I fix ImportError: No module named cv2?"},{"location":"faq/#how-can-i-enable-video-splitting-support","text":"Video splitting is performed by ffmpeg ( https://ffmpeg.org/download.html ) or mkvmerge (https://mkvtoolnix.download/downloads.html) depending on which command line arguments are used. Ensure the tool is available and somewhere in your system's PATH folder.","title":"How can I enable video splitting support?"},{"location":"faq/#how-can-i-fix-the-error-cannot-split-video-due-to-too-many-scenes","text":"This error occurs on Windows platforms specifically when the number of detected scenes is too large. This is because PySceneDetect internally invokes other commands, such as those used for the split-video command. You can get around this issue by simply invoking those tools manually, using a smaller sub-set of scenes (or splitting the scene list into multiple parts). You can obtain a comma-separated list of timecodes by using the list-scenes command. See Issue #164 for details, or if you have any further questions.","title":"How can I fix the error Cannot split video due to too many scenes?"},{"location":"faq/#how-can-i-fix-the-error-failed-to-read-any-frames-from-video-file","text":"Unfortunately, the underlying library used to perform video I/O was unable to open the file. Try using a different backend by installing PyAV ( pip install av ) and see if the problem persists. This can also happen due to videos having multiple audio tracks (as per #179 ). If the PyAV backend does not succeed in processing the video, as a workaround you can remove the audio track using either ffmpeg or mkvmerge : ffmpeg -i input.mp4 -c copy -an output.mp4 Or: mkvmerge -o output.mkv input.mp4","title":"How can I fix the error Failed to read any frames from video file?"},{"location":"features/","text":"Overview Content-Aware Scene Detection Detects breaks in-between content , not only when the video fades to black (although a threshold mode is available as well for those cases). Compatible With Many External Tools The detected scene boundaries/cuts can be exported in a variety of formats, with the default type (comma-separated HH:MM:SS.nnn values) being ready to copy-and-paste directly into other tools (such as ffmpeg, mkvmerge, etc...) for splitting and/or re-encoding the video. Statistical Video Analysis Can output a spreadsheet-compatible file for analyzing trends in a particular video file, to determine the optimal threshold values to use with specific scene detection methods/algorithms. Extendible and Embeddable Written in Python, and designed with an easy-to-use and extendable API, PySceneDetect is ideal for embedding into other programs, or to implement custom methods/algorithms of scene detection for specific applications (e.g. analyzing security camera footage). Features exports list of scenes to .CSV file and terminal (both timecodes and frame numbers) with list-scenes command exports timecodes in standard format (HH:MM:SS.nnn), comma-separated for easy copy-and-paste into external tools and analysis with spreadsheet software statistics/analysis mode to export frame-by-frame video metrics via the -s [FILE] / --stats [FILE] argument (e.g. --stats metrics.csv ) output-suppression (quiet) mode for better automation with external scripts/programs ( -q / --quiet ) save an image of the first and last frame of each detected scene via the save-images command split the input video automatically if ffmpeg or mkvmerge is available via the split-video command Detection Methods PySceneDetect implements a variety of different detection algorithms which can be used independently or combined depending on the source material being analyzed. adaptive content scene detection ( detect-adaptive ): uses rolling average of differences in HSL colorspace combined with thresholding to detect shot changes (fast cut) content-aware scene detection ( detect-content ): uses differences in HSL colorspace combined with filtering to detect shot changes (fast cut) content-aware scene detection ( detect-hash ): uses perceptual hashing to determine differences between frames to find shot changes (fast cut) content-aware scene detection ( detect-hist ): uses differences in histograms of Y channel of frames after conversion to YUV (fast cut) threshold scene detection ( detect-threshold ): uses average frame intensity (brightness) to detect slow transitions (fade in/out) By default, detection methods are tuned to provide high performance during processing, while maintaining reasonable accuracy. Each detection method is configurable, and different parameters can be changed for specific use cases. See the documentation for details. Version Roadmap Future version roadmaps are now tracked as milestones (link) . Specific issues/features that are queued up for the very next release will have the backlog tag , and issues/features being worked on will have the status: in progress tag . Also note that bug reports as well as additional feature requests can be submitted via the issue tracker ; read the Bug Reports and Contributing page for details. Planned Features The following features are under consideration for future releases. Any contributions towards completing these features are most welcome (pull requests may be accpeted via Github). graphical interface (GUI) automatic threshold detection for the current scene detection methods (or just output message indicating \"Predicted Threshold: X\") suppression of short-length flashes/bursts of light #35 histogram-based detection algorithm in HSV/HSL color space #53 perceptual hash based scene detection ( prototype by @wjs018 in PR#290 ) adaptive bias for fade in/out interpolation export scenes in chapter/XML format #323","title":"Features"},{"location":"features/#overview","text":"","title":"Overview"},{"location":"features/#features","text":"exports list of scenes to .CSV file and terminal (both timecodes and frame numbers) with list-scenes command exports timecodes in standard format (HH:MM:SS.nnn), comma-separated for easy copy-and-paste into external tools and analysis with spreadsheet software statistics/analysis mode to export frame-by-frame video metrics via the -s [FILE] / --stats [FILE] argument (e.g. --stats metrics.csv ) output-suppression (quiet) mode for better automation with external scripts/programs ( -q / --quiet ) save an image of the first and last frame of each detected scene via the save-images command split the input video automatically if ffmpeg or mkvmerge is available via the split-video command","title":"Features"},{"location":"features/#detection-methods","text":"PySceneDetect implements a variety of different detection algorithms which can be used independently or combined depending on the source material being analyzed. adaptive content scene detection ( detect-adaptive ): uses rolling average of differences in HSL colorspace combined with thresholding to detect shot changes (fast cut) content-aware scene detection ( detect-content ): uses differences in HSL colorspace combined with filtering to detect shot changes (fast cut) content-aware scene detection ( detect-hash ): uses perceptual hashing to determine differences between frames to find shot changes (fast cut) content-aware scene detection ( detect-hist ): uses differences in histograms of Y channel of frames after conversion to YUV (fast cut) threshold scene detection ( detect-threshold ): uses average frame intensity (brightness) to detect slow transitions (fade in/out) By default, detection methods are tuned to provide high performance during processing, while maintaining reasonable accuracy. Each detection method is configurable, and different parameters can be changed for specific use cases. See the documentation for details.","title":"Detection Methods"},{"location":"features/#version-roadmap","text":"Future version roadmaps are now tracked as milestones (link) . Specific issues/features that are queued up for the very next release will have the backlog tag , and issues/features being worked on will have the status: in progress tag . Also note that bug reports as well as additional feature requests can be submitted via the issue tracker ; read the Bug Reports and Contributing page for details.","title":"Version Roadmap"},{"location":"features/#planned-features","text":"The following features are under consideration for future releases. Any contributions towards completing these features are most welcome (pull requests may be accpeted via Github). graphical interface (GUI) automatic threshold detection for the current scene detection methods (or just output message indicating \"Predicted Threshold: X\") suppression of short-length flashes/bursts of light #35 histogram-based detection algorithm in HSV/HSL color space #53 perceptual hash based scene detection ( prototype by @wjs018 in PR#290 ) adaptive bias for fade in/out interpolation export scenes in chapter/XML format #323","title":"Planned Features"},{"location":"literature/","text":"PySceneDetect in Literature PySceneDetect is a useful tool for statistical analysis of video. Below are links to various research articles/papers which have either used PySceneDetect as a part of their analysis, or propose more accurate detection algorithms using the current implementation as a comparison. Panda-70M: Captioning 70M Videos with Multiple Cross-Modality Teachers by Tsai-Shien Chen, Aliaksandr Siarohin, Willi Menapace, Ekaterina Deyneka, Hsiang-wei Chao, Byung Eun Jeon, Yuwei Fang, Hsin-Ying Lee, Jian Ren, Ming-Hsuan Yang, Sergey Tulyakov (2024) Stable Remaster: Bridging the Gap Between Old Content and New Displays by Nathan Paull, Shuvam Keshari, Yian Wong (2023) LoL-V2T: Large-Scale Esports Video Description Dataset by Tsunehiko Tanaka, Edgar Simo-Serra (2021) Online Detection of Action Start via Soft Computing for Smart City by Tian Wang, Yang Chen, Hongqiang Lv, Jing Teng, Hichem Snoussi, Fei Tao (2020) Thesis Project: Smart Shades and Cane for The Blind by Muhammad Hashim (2020) Movienet: a movie multilayer network model using visual and textual semantic cues by Youssef Mourchid, Benjamin Renoust, Olivier Roupin, L\u00ea V\u0103n, Hocine Cherifi & Mohammed El Hassouni (2019) NLP-Enriched Automatic Video Segmentation by Mohannad AlMousa, Rachid Benlamri, Richard Khoury (2018) Online Detection of Action Start in Untrimmed, Streaming Videos by Zheng Shou, Junting Pan, Jonathan Chan, Kazuyuki Miyazawa, Hassan Mansour, Anthony Vetro, Xavi Gir-i-Nieto, Shih-Fu Chang (2018) Story Understanding in Video Advertisements by Keren Ye, Kyle Buettner, Adriana Kovashka (2018) This list is only provided for academic and research purposes, and is far from an exhaustive source of the uses of PySceneDetect in literature. If you think a particular submission is relevant and should be added to this list, feel free to raise an issue with your suggestion. Publicly available material is preferred, although not a requirement. Scene Detection Methodology You can find the source code for each scene detector in the scenedetect/detectors folder . Also see Issue #62: Reference of paper for the methods used on Github for a further discussion on detection methodologies. You are more than welcome to propose any new ideas on the issue tracker , or share a proof of concept using the Python API by creating a pull request.","title":"Research & Literature"},{"location":"literature/#pyscenedetect-in-literature","text":"PySceneDetect is a useful tool for statistical analysis of video. Below are links to various research articles/papers which have either used PySceneDetect as a part of their analysis, or propose more accurate detection algorithms using the current implementation as a comparison. Panda-70M: Captioning 70M Videos with Multiple Cross-Modality Teachers by Tsai-Shien Chen, Aliaksandr Siarohin, Willi Menapace, Ekaterina Deyneka, Hsiang-wei Chao, Byung Eun Jeon, Yuwei Fang, Hsin-Ying Lee, Jian Ren, Ming-Hsuan Yang, Sergey Tulyakov (2024) Stable Remaster: Bridging the Gap Between Old Content and New Displays by Nathan Paull, Shuvam Keshari, Yian Wong (2023) LoL-V2T: Large-Scale Esports Video Description Dataset by Tsunehiko Tanaka, Edgar Simo-Serra (2021) Online Detection of Action Start via Soft Computing for Smart City by Tian Wang, Yang Chen, Hongqiang Lv, Jing Teng, Hichem Snoussi, Fei Tao (2020) Thesis Project: Smart Shades and Cane for The Blind by Muhammad Hashim (2020) Movienet: a movie multilayer network model using visual and textual semantic cues by Youssef Mourchid, Benjamin Renoust, Olivier Roupin, L\u00ea V\u0103n, Hocine Cherifi & Mohammed El Hassouni (2019) NLP-Enriched Automatic Video Segmentation by Mohannad AlMousa, Rachid Benlamri, Richard Khoury (2018) Online Detection of Action Start in Untrimmed, Streaming Videos by Zheng Shou, Junting Pan, Jonathan Chan, Kazuyuki Miyazawa, Hassan Mansour, Anthony Vetro, Xavi Gir-i-Nieto, Shih-Fu Chang (2018) Story Understanding in Video Advertisements by Keren Ye, Kyle Buettner, Adriana Kovashka (2018) This list is only provided for academic and research purposes, and is far from an exhaustive source of the uses of PySceneDetect in literature. If you think a particular submission is relevant and should be added to this list, feel free to raise an issue with your suggestion. Publicly available material is preferred, although not a requirement.","title":"PySceneDetect in Literature"},{"location":"literature/#scene-detection-methodology","text":"You can find the source code for each scene detector in the scenedetect/detectors folder . Also see Issue #62: Reference of paper for the methods used on Github for a further discussion on detection methodologies. You are more than welcome to propose any new ideas on the issue tracker , or share a proof of concept using the Python API by creating a pull request.","title":"Scene Detection Methodology"},{"location":"similar/","text":"Alternative and Related Programs The following is a list of programs or commands also performing scene cut analysis of some kind on video files. Additions/contributions to this list are welcome . Scenecut Extractor - uses ffmpeg select filter ffmpeg blackframe filter ( thanks @tonycpsu ) - threshold mode only Shotdetect - appears to be only for *NIX, content mode only Matlab Scene Change Detection - requires Matlab and Simulink/Computer Vision Toolbox, uses feature extraction and edge detection chaptertool - CLI/Web tool that converts PySceneDetect output to other formats TransNetV2 - Shot Boundary Detection Neural Network (2020) [AutoShot] https://github.com/wentaozhu/AutoShot - Shot Boundary Detection Neural Network, based on a neural architecture search (2023)","title":"Similar Projects"},{"location":"similar/#alternative-and-related-programs","text":"The following is a list of programs or commands also performing scene cut analysis of some kind on video files. Additions/contributions to this list are welcome . Scenecut Extractor - uses ffmpeg select filter ffmpeg blackframe filter ( thanks @tonycpsu ) - threshold mode only Shotdetect - appears to be only for *NIX, content mode only Matlab Scene Change Detection - requires Matlab and Simulink/Computer Vision Toolbox, uses feature extraction and edge detection chaptertool - CLI/Web tool that converts PySceneDetect output to other formats TransNetV2 - Shot Boundary Detection Neural Network (2020) [AutoShot] https://github.com/wentaozhu/AutoShot - Shot Boundary Detection Neural Network, based on a neural architecture search (2023)","title":"Alternative and Related Programs"},{"location":"supporting/","text":"Supporting Development This page is dedicated to the various people, tools, technologies, and companies which support the development of PySceneDetect. This page has been created to give credit to the things which allow PySceneDetect to exist, and is not meant to imply any kind of endorsement. Tools, Technologies, and Companies The development of PySceneDetect is supported by the following tools, technologies, and companies: Github - Git and website hosting, code review, issue tracking, Linux/Windows/OSX builds AppVeyor - Windows builds (portable + MSI) AdvancedInstaller - MSI installer SignPath - Code signing for Windows builds Special thanks to these companies for their support. Community Contributions PySceneDetect is an open source project which anyone can freely contribute to (see this page for various ways you can contribute ). You can view the contribution graph on Github or visit PySceneDetect at libraries.io or view the to see a list detailing the contributions people have made to the PySceneDetect project. In addition to those who have made a direct contribution in the form of a pull request, a special thank you to everyone who has submitted an issue, bug report, feature request, and/or pull request (see the links above for complete lists), as well as for those who continue to help the ongoing development of PySceneDetect. Your contributions continue to improve PySceneDetect, highlight the assets and talents of the FOSS community, and help to make the project's goal of being the most accurate scene detection program/library become a reality. Lastly, thank you all for your help, support, feedback, and direction on the project. Donations Monetary donations are not accepted for the project, but there are ways you can contribute to the project. Furthermore, if you have resources, tools, or technologies which may benefit the development of PySceneDetect, please feel free to contact me via the issue tracker or my website . Many thanks to everyone who continually supports the development of the project.","title":"Development & Support"},{"location":"supporting/#supporting-development","text":"This page is dedicated to the various people, tools, technologies, and companies which support the development of PySceneDetect. This page has been created to give credit to the things which allow PySceneDetect to exist, and is not meant to imply any kind of endorsement.","title":"&nbsp; Supporting Development"},{"location":"supporting/#tools-technologies-and-companies","text":"The development of PySceneDetect is supported by the following tools, technologies, and companies: Github - Git and website hosting, code review, issue tracking, Linux/Windows/OSX builds AppVeyor - Windows builds (portable + MSI) AdvancedInstaller - MSI installer SignPath - Code signing for Windows builds Special thanks to these companies for their support.","title":"&nbsp; Tools, Technologies, and Companies"},{"location":"supporting/#community-contributions","text":"PySceneDetect is an open source project which anyone can freely contribute to (see this page for various ways you can contribute ). You can view the contribution graph on Github or visit PySceneDetect at libraries.io or view the to see a list detailing the contributions people have made to the PySceneDetect project. In addition to those who have made a direct contribution in the form of a pull request, a special thank you to everyone who has submitted an issue, bug report, feature request, and/or pull request (see the links above for complete lists), as well as for those who continue to help the ongoing development of PySceneDetect. Your contributions continue to improve PySceneDetect, highlight the assets and talents of the FOSS community, and help to make the project's goal of being the most accurate scene detection program/library become a reality. Lastly, thank you all for your help, support, feedback, and direction on the project.","title":"&nbsp; Community Contributions"},{"location":"supporting/#donations","text":"Monetary donations are not accepted for the project, but there are ways you can contribute to the project. Furthermore, if you have resources, tools, or technologies which may benefit the development of PySceneDetect, please feel free to contact me via the issue tracker or my website . Many thanks to everyone who continually supports the development of the project.","title":"&nbsp; Donations"}]}